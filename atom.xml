<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[etund喔喔喔]]></title>
  <link href="http://etund.github.com/atom.xml" rel="self"/>
  <link href="http://etund.github.com/"/>
  <updated>2015-09-05T20:41:21+08:00</updated>
  <id>http://etund.github.com/</id>
  <author>
    <name><![CDATA[etund]]></name>
    <email><![CDATA[a925813235z@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[QQ粘性效果实现详细步骤]]></title>
    <link href="http://etund.github.com/blog/2015/08/31/qqnian-xing-xiao-guo/"/>
    <updated>2015-08-31T23:39:43+08:00</updated>
    <id>http://etund.github.com/blog/2015/08/31/qqnian-xing-xiao-guo</id>
    <content type="html"><![CDATA[<h2>QQ粘性效果实现详细步骤</h2>

<ul>
<li>思路

<ul>
<li>新建自定义UIButton</li>
<li>添加拖动手势</li>
<li>计算圆的变化</li>
<li>计算圆之间矩形并且填充</li>
<li>回弹</li>
<li>爆炸</li>
</ul>
</li>
<li>步骤

<ul>
<li>先完成空间布局以及手势添加</li>
<li>然后计算圆的变化，计算圆之间的矩形面积</li>
<li>效果微调</li>
</ul>
</li>
</ul>


<h2>先看看完成后的效果图</h2>

<p><img src="http://etund.github.com/images/blog/QQnianxingxiaoguo/bug_1.gif" alt="效果图" /></p>

<!-- more -->


<h2>再看看代码结构图</h2>

<p><img src="http://etund.github.com/images/blog/QQnianxingxiaoguo/Snip20150625_1.png" alt="代码结构" /></p>

<h3>详细步骤</h3>

<ul>
<li>在一个storyBoard里面拖一个UIButton进去，然后新建一个自定义UIBUtton类 如：ETBUtton类与之对应，好了，一切新建工作完毕，下面，我们只需要在自定义的UIButton类里面做功夫就好了，简单的代码直接上好了。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;ETStickBtn.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">ETStickBtn</span> <span class="p">()</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">UIView</span> <span class="o">*</span><span class="n">smalCirView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="bp">NSInteger</span> <span class="n">oriRadius</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">CAShapeLayer</span> <span class="o">*</span><span class="n">shapeLayer</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ETStickBtn</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 懒加载数据</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">smalCirView</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_smalCirView</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//    新建一个圆</span>
</span><span class='line'>        <span class="bp">UIView</span> <span class="o">*</span><span class="n">smalCirView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="c1">//        smalCirView.frame = self.frame;</span>
</span><span class='line'>        <span class="n">smalCirView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">superview</span> <span class="nl">insertSubview</span><span class="p">:</span><span class="n">smalCirView</span> <span class="nl">belowSubview</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_smalCirView</span> <span class="o">=</span> <span class="n">smalCirView</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_smalCirView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">CAShapeLayer</span> <span class="o">*</span><span class="p">)</span><span class="nf">shapeLayer</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_shapeLayer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">CAShapeLayer</span> <span class="o">*</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAShapeLayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'>        <span class="n">shapeLayer</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">.</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">superview</span><span class="p">.</span><span class="n">layer</span> <span class="nl">insertSublayer</span><span class="p">:</span><span class="n">shapeLayer</span> <span class="nl">below</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_shapeLayer</span> <span class="o">=</span> <span class="n">shapeLayer</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_shapeLayer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 系统初始化</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithFrame:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">frame</span><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="n">setUp</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">awakeFromNib</span><span class="p">{</span>
</span><span class='line'>     <span class="p">[</span><span class="nb">self</span> <span class="n">setUp</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 初始化视图</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUp</span><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="c1">//    记录半径</span>
</span><span class='line'>    <span class="n">_oriRadius</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">pan</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">pan</span><span class="p">:)];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">pan</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在添加完Pan手势后当然我们要在自定义的Pan方法里面做功夫，先看看已经实现了拖动效果的Pan代码块吧</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pan:</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pan</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  移动</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">transPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">pan</span> <span class="nl">translationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pan</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>就这样，可以拖动啦，接下来你想做什么呢？我就想你不断拖动大圆的过程中，小圆的半径一直减少直到为0，<code>具体思路是圆心距越大，小圆半径越小</code>，这是奉上此时的Pan代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pan:</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pan</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  移动</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">transPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">pan</span> <span class="nl">translationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pan</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  设置小圆变化的值</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cirDistance</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="n">_oriRadius</span> <span class="o">-</span> <span class="n">cirDistance</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">smallCirRadius</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">smallCirRadius</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 获取圆心距离</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">distanceWithPointA:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">pointA</span>  <span class="nf">andPointB:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">pointB</span><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">offSetX</span> <span class="o">=</span> <span class="n">pointA</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pointB</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">offSetY</span> <span class="o">=</span> <span class="n">pointA</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pointB</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">offSetX</span><span class="o">*</span><span class="n">offSetX</span> <span class="o">+</span> <span class="n">offSetY</span><span class="o">*</span><span class="n">offSetY</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>好了，现在小圆终于可以随着两圆心距的变大而变小了，之后重头戏来了，获取贝塞尔曲线路径，也就是绘制两圆之间的曲线部分<img src="http://etund.github.com/images/blog/QQnianxingxiaoguo/Snip20150625_12.png" alt="要计算的部分" />，这个也不难，只是用到初中的知识，先上个原型图(手绘)<img src="http://etund.github.com/images/blog/QQnianxingxiaoguo/Snip20150626_2.png" alt="建模" />,咳咳，由于用铅笔画的，有点模糊，那就奉上一个比较好看的吧<img src="http://etund.github.com/images/blog/QQnianxingxiaoguo/%E7%B2%98%E6%80%A7%E8%AE%A1%E7%AE%97%E5%9B%BE.png" alt="建模" />，至此，重要的点都已经计算出来的，也不难吧，把算式换成代码如下</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIBezierPath</span> <span class="o">*</span><span class="p">)</span><span class="nf">getBezierPathWithSmallCir:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">smallCir</span> <span class="nf">andBigCir:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">bigCir</span><span class="p">{</span>
</span><span class='line'><span class="c1">//    获取最小的圆</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">bigCir</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">;</span>
</span><span class='line'>        <span class="n">bigCir</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">;</span>
</span><span class='line'>        <span class="n">smallCir</span> <span class="o">=</span> <span class="n">view</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="c1">//    获取小圆的信息</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="n">smallCir</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="n">bigCir</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取大圆的信息</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取三角函数</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">sinA</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cosA</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取矩形四个点</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointA</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r1</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointB</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r1</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointC</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r2</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointD</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取控制点，以便画出曲线</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointO</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">pointA</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cosA</span> <span class="p">,</span> <span class="n">pointA</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sinA</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointP</span> <span class="o">=</span>  <span class="n">CGPointMake</span><span class="p">(</span><span class="n">pointB</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cosA</span> <span class="p">,</span> <span class="n">pointB</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sinA</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    创建路径</span>
</span><span class='line'>    <span class="bp">UIBezierPath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span><span class="p">[</span><span class="bp">UIBezierPath</span> <span class="n">bezierPath</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">moveToPoint</span><span class="p">:</span><span class="n">pointA</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint</span><span class="p">:</span><span class="n">pointB</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addQuadCurveToPoint</span><span class="p">:</span><span class="n">pointC</span> <span class="nl">controlPoint</span><span class="p">:</span><span class="n">pointP</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint</span><span class="p">:</span><span class="n">pointD</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addQuadCurveToPoint</span><span class="p">:</span><span class="n">pointA</span> <span class="nl">controlPoint</span><span class="p">:</span><span class="n">pointO</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    获取最小的圆</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">bigCir</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">;</span>
</span><span class='line'>        <span class="n">bigCir</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">;</span>
</span><span class='line'>        <span class="n">smallCir</span> <span class="o">=</span> <span class="n">view</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>就是这段代码，由于我作图是小圆的圆心为x1 y1,所以如果把大圆小圆的位置调过来会导致曲线面积的中间鼓起来，所以为了防止别人传错值，也不用他们那么纠结了，我代码里面自己找出最小的圆就好了，所以一定要加上这一句，然后奉上此时的pan代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pan:</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pan</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  移动</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">transPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">pan</span> <span class="nl">translationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pan</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  设置小圆变化的值</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cirDistance</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="n">_oriRadius</span> <span class="o">-</span> <span class="n">cirDistance</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">smallCirRadius</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">smallCirRadius</span><span class="p">;</span>
</span><span class='line'>      <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">getBezierPathWithSmallCir</span><span class="p">:</span><span class="nb">self</span> <span class="nl">andBigCir</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">].</span><span class="bp">CGPath</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>好了接下来就是收尾部分了，只是我想做在超过一定距离后，按钮就完全被拖走了 依依不舍的走了。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - 自定义方法</span>
</span><span class='line'><span class="cp">#pragma mark - 手势触发方法</span>
</span><span class='line'><span class="cp">#define MaxDistance 90</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pan:</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pan</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  移动</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">transPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">pan</span> <span class="nl">translationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pan</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  设置小圆变化的值</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cirDistance</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="n">_oriRadius</span> <span class="o">-</span> <span class="n">cirDistance</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">smallCirRadius</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">smallCirRadius</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">//    画图</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="n">MaxDistance</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="n">removeFromSuperlayer</span><span class="p">];</span>
</span><span class='line'><span class="c1">//        self.smalCirView  = nil;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">==</span> <span class="nb">NO</span> <span class="o">&amp;&amp;</span> <span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>         <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">getBezierPathWithSmallCir</span><span class="p">:</span><span class="nb">self</span> <span class="nl">andBigCir</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">].</span><span class="bp">CGPath</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最后，我们判断在限定范围内放手就回弹，超过就爆炸消失</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - 自定义方法</span>
</span><span class='line'><span class="cp">#pragma mark - 手势触发方法</span>
</span><span class='line'><span class="cp">#define MaxDistance 90</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pan:</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pan</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  移动</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">transPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">pan</span> <span class="nl">translationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pan</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  设置小圆变化的值</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cirDistance</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="n">_oriRadius</span> <span class="o">-</span> <span class="n">cirDistance</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">smallCirRadius</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">smallCirRadius</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">//    画图</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="n">MaxDistance</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="n">removeFromSuperlayer</span><span class="p">];</span>
</span><span class='line'><span class="c1">//        self.smalCirView  = nil;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">==</span> <span class="nb">NO</span> <span class="o">&amp;&amp;</span> <span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>         <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">getBezierPathWithSmallCir</span><span class="p">:</span><span class="nb">self</span> <span class="nl">andBigCir</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">].</span><span class="bp">CGPath</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="c1">//    爆炸或还原</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">pan</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateBegan</span><span class="p">){</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">NSStringFromCGRect</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pan</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="n">MaxDistance</span><span class="p">){</span>
</span><span class='line'><span class="c1">//            这是动画的爆炸效果</span>
</span><span class='line'>            <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">imageView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">NSStringFromCGRect</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'>            <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">imageArr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>                <span class="p">[</span><span class="n">imageArr</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">image</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">imageView</span><span class="p">.</span><span class="n">animationImages</span> <span class="o">=</span> <span class="n">imageArr</span><span class="p">;</span>
</span><span class='line'>            <span class="n">imageView</span><span class="p">.</span><span class="n">animationDuration</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'>            <span class="n">imageView</span><span class="p">.</span><span class="n">animationRepeatCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">[</span><span class="n">imageView</span> <span class="n">startAnimating</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">imageView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'><span class="c1">//                移除控件</span>
</span><span class='line'>                <span class="p">[</span><span class="nb">self</span> <span class="n">removeFromSuperview</span><span class="p">];</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'><span class="c1">//            回弹</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="n">removeFromSuperlayer</span><span class="p">];</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>            <span class="p">[</span><span class="bp">UIView</span> <span class="nl">animateWithDuration</span><span class="p">:</span><span class="mf">0.5</span> <span class="nl">delay</span><span class="p">:</span><span class="mi">0</span> <span class="nl">usingSpringWithDamping</span><span class="p">:</span><span class="mf">0.2</span> <span class="nl">initialSpringVelocity</span><span class="p">:</span><span class="mi">0</span> <span class="nl">options</span><span class="p">:</span><span class="n">UIViewAnimationOptionCurveLinear</span> <span class="nl">animations</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="nl">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这时基本上已经可以宣告完成的了，但是在爆炸效果释放的时候你会发现，爆炸效果不在我们当前的位置爆炸，而是在初始位置爆炸，这是因为苹果官方自动给StoryBoard添加了自动布局约束，这是只需要把约束渲染设为NO就好了，就是在ViewController里面加上一句代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最后奉上整个类的代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;ETStickBtn.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">ETStickBtn</span> <span class="p">()</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">UIView</span> <span class="o">*</span><span class="n">smalCirView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="bp">NSInteger</span> <span class="n">oriRadius</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">CAShapeLayer</span> <span class="o">*</span><span class="n">shapeLayer</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ETStickBtn</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 懒加载数据</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">smalCirView</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_smalCirView</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//    新建一个圆</span>
</span><span class='line'>        <span class="bp">UIView</span> <span class="o">*</span><span class="n">smalCirView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="c1">//        smalCirView.frame = self.frame;</span>
</span><span class='line'>        <span class="n">smalCirView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">superview</span> <span class="nl">insertSubview</span><span class="p">:</span><span class="n">smalCirView</span> <span class="nl">belowSubview</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_smalCirView</span> <span class="o">=</span> <span class="n">smalCirView</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_smalCirView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">CAShapeLayer</span> <span class="o">*</span><span class="p">)</span><span class="nf">shapeLayer</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_shapeLayer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">CAShapeLayer</span> <span class="o">*</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAShapeLayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'>        <span class="n">shapeLayer</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">.</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">superview</span><span class="p">.</span><span class="n">layer</span> <span class="nl">insertSublayer</span><span class="p">:</span><span class="n">shapeLayer</span> <span class="nl">below</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">layer</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_shapeLayer</span> <span class="o">=</span> <span class="n">shapeLayer</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_shapeLayer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 系统初始化</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithFrame:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">frame</span><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="n">setUp</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">awakeFromNib</span><span class="p">{</span>
</span><span class='line'>     <span class="p">[</span><span class="nb">self</span> <span class="n">setUp</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 初始化视图</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUp</span><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="c1">//    记录半径</span>
</span><span class='line'>    <span class="n">_oriRadius</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">pan</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">pan</span><span class="p">:)];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">pan</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 自定义方法</span>
</span><span class='line'><span class="cp">#pragma mark - 手势触发方法</span>
</span><span class='line'><span class="cp">#define MaxDistance 90</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pan:</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pan</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  移动</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">transPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">pan</span> <span class="nl">translationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">transPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pan</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  设置小圆变化的值</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cirDistance</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="n">_oriRadius</span> <span class="o">-</span> <span class="n">cirDistance</span><span class="o">/</span><span class="mf">10.0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">smallCirRadius</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">smallCirRadius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_smalCirView</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">smallCirRadius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">smallCirRadius</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">//    画图</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="n">MaxDistance</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="n">removeFromSuperlayer</span><span class="p">];</span>
</span><span class='line'><span class="c1">//        self.smalCirView  = nil;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">==</span> <span class="nb">NO</span> <span class="o">&amp;&amp;</span> <span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>         <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">getBezierPathWithSmallCir</span><span class="p">:</span><span class="nb">self</span> <span class="nl">andBigCir</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">].</span><span class="bp">CGPath</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="c1">//    爆炸或还原</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">pan</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateBegan</span><span class="p">){</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">NSStringFromCGRect</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pan</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cirDistance</span> <span class="o">&gt;</span> <span class="n">MaxDistance</span><span class="p">){</span>
</span><span class='line'><span class="c1">//            这是动画的爆炸效果</span>
</span><span class='line'>            <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">imageView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">NSStringFromCGRect</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'>            <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">imageArr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>                <span class="p">[</span><span class="n">imageArr</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">image</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">imageView</span><span class="p">.</span><span class="n">animationImages</span> <span class="o">=</span> <span class="n">imageArr</span><span class="p">;</span>
</span><span class='line'>            <span class="n">imageView</span><span class="p">.</span><span class="n">animationDuration</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'>            <span class="n">imageView</span><span class="p">.</span><span class="n">animationRepeatCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">[</span><span class="n">imageView</span> <span class="n">startAnimating</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">imageView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'><span class="c1">//                移除控件</span>
</span><span class='line'>                <span class="p">[</span><span class="nb">self</span> <span class="n">removeFromSuperview</span><span class="p">];</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'><span class="c1">//            回弹</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="n">removeFromSuperlayer</span><span class="p">];</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">shapeLayer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>            <span class="p">[</span><span class="bp">UIView</span> <span class="nl">animateWithDuration</span><span class="p">:</span><span class="mf">0.5</span> <span class="nl">delay</span><span class="p">:</span><span class="mi">0</span> <span class="nl">usingSpringWithDamping</span><span class="p">:</span><span class="mf">0.2</span> <span class="nl">initialSpringVelocity</span><span class="p">:</span><span class="mi">0</span> <span class="nl">options</span><span class="p">:</span><span class="n">UIViewAnimationOptionCurveLinear</span> <span class="nl">animations</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="nl">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">smalCirView</span><span class="p">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 获取圆心距离</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">distanceWithPointA:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">pointA</span>  <span class="nf">andPointB:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">pointB</span><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">offSetX</span> <span class="o">=</span> <span class="n">pointA</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">pointB</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">offSetY</span> <span class="o">=</span> <span class="n">pointA</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">pointB</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">offSetX</span><span class="o">*</span><span class="n">offSetX</span> <span class="o">+</span> <span class="n">offSetY</span><span class="o">*</span><span class="n">offSetY</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 获取贝塞尔曲线</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIBezierPath</span> <span class="o">*</span><span class="p">)</span><span class="nf">getBezierPathWithSmallCir:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">smallCir</span> <span class="nf">andBigCir:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">bigCir</span><span class="p">{</span>
</span><span class='line'><span class="c1">//    获取最小的圆</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">bigCir</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">;</span>
</span><span class='line'>        <span class="n">bigCir</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">;</span>
</span><span class='line'>        <span class="n">smallCir</span> <span class="o">=</span> <span class="n">view</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="c1">//    获取小圆的信息</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">distanceWithPointA</span><span class="p">:</span><span class="n">smallCir</span><span class="p">.</span><span class="n">center</span> <span class="nl">andPointB</span><span class="p">:</span><span class="n">bigCir</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">smallCir</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取大圆的信息</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">bigCir</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取三角函数</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">sinA</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">cosA</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取矩形四个点</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointA</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r1</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointB</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r1</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointC</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r2</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointD</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">sinA</span><span class="o">*</span><span class="n">r2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">cosA</span> <span class="o">*</span> <span class="n">r2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    获取控制点，以便画出曲线</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointO</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">pointA</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cosA</span> <span class="p">,</span> <span class="n">pointA</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sinA</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">pointP</span> <span class="o">=</span>  <span class="n">CGPointMake</span><span class="p">(</span><span class="n">pointB</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cosA</span> <span class="p">,</span> <span class="n">pointB</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sinA</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//    创建路径</span>
</span><span class='line'>    <span class="bp">UIBezierPath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span><span class="p">[</span><span class="bp">UIBezierPath</span> <span class="n">bezierPath</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">moveToPoint</span><span class="p">:</span><span class="n">pointA</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint</span><span class="p">:</span><span class="n">pointB</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addQuadCurveToPoint</span><span class="p">:</span><span class="n">pointC</span> <span class="nl">controlPoint</span><span class="p">:</span><span class="n">pointP</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint</span><span class="p">:</span><span class="n">pointD</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">path</span> <span class="nl">addQuadCurveToPoint</span><span class="p">:</span><span class="n">pointA</span> <span class="nl">controlPoint</span><span class="p">:</span><span class="n">pointO</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>好了，收工</p>

<ul>
<li>后期更新(如果想获得呼吸效果，只需要加上一个帧动画即可)，上面的完整代码里面没有动画，如果想添加动画，请看下面

<ul>
<li>动画代码</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - 添加动画</span>
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">AddAniamtionLikeGameCenterBubble</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">pathAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">calculationMode</span> <span class="o">=</span> <span class="n">kCAAnimationPaced</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForwards</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">];</span>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGMutablePathRef</span> <span class="n">curvedPath</span> <span class="o">=</span> <span class="n">CGPathCreateMutable</span><span class="p">();</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">circleContainer</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGPathAddEllipseInRect</span><span class="p">(</span><span class="n">curvedPath</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">circleContainer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">pathAnimation</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">curvedPath</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGPathRelease</span><span class="p">(</span><span class="n">curvedPath</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">pathAnimation</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;myCircleAnimation&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="bp">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">scaleX</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;transform.scale.x&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="l">@[</span><span class="mf">@1.0</span><span class="p">,</span> <span class="mf">@1.1</span><span class="p">,</span> <span class="mf">@1.0</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="l">@[</span><span class="mf">@0.0</span><span class="p">,</span> <span class="mf">@0.5</span><span class="p">,</span> <span class="mf">@1.0</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionEaseInEaseOut</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">scaleX</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;scaleXAnimation&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="bp">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">scaleY</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;transform.scale.y&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">scaleY</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleY</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="l">@[</span><span class="mf">@1.0</span><span class="p">,</span> <span class="mf">@1.1</span><span class="p">,</span> <span class="mf">@1.0</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleY</span><span class="p">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="l">@[</span><span class="mf">@0.0</span><span class="p">,</span> <span class="mf">@0.5</span><span class="p">,</span> <span class="mf">@1.0</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleY</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleY</span><span class="p">.</span><span class="n">autoreverses</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scaleX</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAMediaTimingFunction</span> <span class="nl">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionEaseInEaseOut</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">scaleY</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;scaleYAnimation&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - 移除动画</span>
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">RemoveAniamtionLikeGameCenterBubble</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">layer</span> <span class="n">removeAllAnimations</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程回顾]]></title>
    <link href="http://etund.github.com/blog/2015/08/25/duo-xian-cheng-%5B%3F%5D/"/>
    <updated>2015-08-25T22:13:01+08:00</updated>
    <id>http://etund.github.com/blog/2015/08/25/duo-xian-cheng-[?]</id>
    <content type="html"><![CDATA[<h4>简单回顾</h4>

<ul>
<li>iOS中多线程实现有几种方案？

<ul>
<li>首先搞清楚什么是线程，什么是多线程。</li>
<li>Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现方式是基于Mach的线程的。</li>
<li>开发中很少用Mach级的线程，因为Mach级的的线程没有提供多线程的基本特征线程之间是独立的。</li>
<li>基本实现

<ul>
<li>pthead，纯C，手动管理生命周期</li>
<li>NSThread，OC，面向对象。手动管理内存</li>
<li>GCD，纯C，自动管理生命周期，大中央调度，要理解队列与任务，任务在队列里面去除遵循先进先出的准则。</li>
<li>NSOperation,OC，基于GCD的封装，自动管理生命周期，把操作(NSOperation)放进队列(NSOperationQueue)里面，里面的额操作会异步执行。</li>
</ul>
</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>线程间怎么通信？</p>

<ul>
<li>perfromSelectior:onThead:withObjecti:waitUntilDone:</li>
<li>NSMachPort(在RunLoop里面的source0和source1里面)</li>
</ul>
</li>
<li><p>cocoa常见的多线程实现</p>

<ul>
<li>只有在主线程刷新访问UI</li>
<li>如果要保证属性的线程安全（atomic）</li>
<li>如果一部操作要保证线程安全等问题，尽量使用GCD</li>
<li>如果想要定时器精确，用GCD定时器</li>
</ul>
</li>
<li><p>GCD内部实现</p>

<ul>
<li>iOS和OSX的黑心是XNU内核，GCD是基于XNU内核实现的</li>
<li>GCD的API全部在libdiPatch库中</li>
<li>GCD的底层实现主要有DispatchQueue和DispatchSource

<ul>
<li>DispatchQueue:管理block(操作)</li>
<li>DispatchSource:处理事件(MACH端口发送，MACH端口接收，监测与进程的事件的10种事件)</li>
</ul>
</li>
</ul>
</li>
<li><p>NSOperation相对于GCD的优点</p>

<ul>
<li>面向对象</li>
<li>封装性好</li>
<li>提供便利的方法</li>
<li>支持KVO,可以监测operation是否正在执行(isExecuted),是否结束(isFinished)，是否取消(isCancled)</li>
<li>GCD的执行速度比NSOperationQueue快</li>
<li>选择

<ul>
<li>任务需要依赖或者要监听任务的执行情况，用NSOperationQueue</li>
</ul>
</li>
<li>在使用GCD的时候要防止循环引用

<ul>
<li>ARC:_weak_unsafe_unretained</li>
<li>MRC:_block</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原谅我这一生不羁放纵爱自由]]></title>
    <link href="http://etund.github.com/blog/2015/08/21/yuan-liang-wo-zhe-%5B%3F%5D-sheng-bu-ji-fang-zong-ai-zi-you/"/>
    <updated>2015-08-21T22:13:01+08:00</updated>
    <id>http://etund.github.com/blog/2015/08/21/yuan-liang-wo-zhe-[?]-sheng-bu-ji-fang-zong-ai-zi-you</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程(二)]]></title>
    <link href="http://etund.github.com/blog/2015/07/08/iosduo-xian-cheng-er/"/>
    <updated>2015-07-08T20:33:34+08:00</updated>
    <id>http://etund.github.com/blog/2015/07/08/iosduo-xian-cheng-er</id>
    <content type="html"><![CDATA[<h2>iOS多线程(二)</h2>

<h3>NSOperation</h3>

<ul>
<li>NSOperation是对GCD的封装，既然封装了，那么就没有GCD那么好玩，但是同时也更加便捷的实现以下常用的功能。

<ul>
<li>创建：NSOperation是一个抽象类，不能实例化，但可以通过他的子类来使用，子类分别是NSBlockOperation和NSInvocationOperation，创建方式如下。</li>
</ul>
</li>
</ul>


<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//NSBlockOperation</span>
</span><span class='line'>  <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">opeaBlock</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----1---%@-&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">])</span> <span class="p">;</span>
</span><span class='line'>  <span class="p">}];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">opeaBlock</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>  <span class="err">或者</span>
</span><span class='line'><span class="c1">//    NSInvocationOperation</span>
</span><span class='line'>  <span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">invoOpera</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span><span class="s">@&quot;etund&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">invoOpera</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>  <span class="cm">/*运行结果</span>
</span><span class='line'><span class="cm">   2015-07-09 14:00:18.610 Pthread-多平台[91622:193993] ----1---&lt;NSThread: 0x7fc26ae193c0&gt;{number = 1, name = main}---- etund</span>
</span><span class='line'><span class="cm">   */</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>此外，还可以通过自定义类继承NSOperation来使用NSOperation，注意在继承NSOperation的实现中把你想要执行的代码块放进- (void)main;里面就行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ETOperation</span><span class="p">.</span><span class="n">m</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">main</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;-----1-%@&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//调用</span>
</span><span class='line'><span class="c1">//      自定义NSOperation</span>
</span><span class='line'>    <span class="n">ETOpearation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ETOpearation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">operation</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>    <span class="cm">/*运行结果</span>
</span><span class='line'><span class="cm">     2015-07-09 14:00:18.610 Pthread-多平台[91622:193993] ----1---&lt;NSThread: 0x7fc26ae193c0&gt;{number = 1, name = main}---- etund</span>
</span><span class='line'><span class="cm">     */</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>以上线程都没有开启子线程，我们可以用NSOperationQueue与NSOperation结合使用来实现多线程操作，具体做法是把NSOperation实例加到NSOperationQueue队列中，当我们把实例加入队列中的时候，就不用主动调用start方法来开启线程了，线程会自动开启。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    NSOperationQueue</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="c1">//    自定义NSOperation实例</span>
</span><span class='line'><span class="n">ETOpearation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span>  <span class="p">[[</span><span class="n">ETOpearation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">opeaBlock</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----1---%@-&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">])</span> <span class="p">;</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">invoOpera</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="s">@&quot;etund&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">opeaBlock</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">invoOpera</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">operation</span><span class="p">];</span>
</span><span class='line'><span class="cm">/*运行结果</span>
</span><span class='line'><span class="cm"> 2015-07-09 14:24:26.191 Pthread-多平台[98921:212686] -----1-&lt;NSThread: 0x7ff1eab20440&gt;{number = 5, name = (null)}</span>
</span><span class='line'><span class="cm"> 2015-07-09 14:24:26.191 Pthread-多平台[98921:212687] ----1---&lt;NSThread: 0x7ff1eab20190&gt;{number = 4, name = (null)}-</span>
</span><span class='line'><span class="cm"> 2015-07-09 14:24:26.191 Pthread-多平台[98921:212689] ----1---&lt;NSThread: 0x7ff1eaa37910&gt;{number = 3, name = (null)}---- etund</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<p>&mdash;&mdash;&ndash;注意看上面运行结果，已经创建了多个线程了，至此我们成功的利用NSOperationQueue以及NSOperation实现多线程操作。</p>

<ul>
<li>我们也可以直接在队列里面添加线程代码块，就可以省去新建NSOperation实例</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    NSOperationQueue</span>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=======1==%@&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=======2==%@&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=======3==%@&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=======4==%@&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=======5==%@&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="cm">/*运行结果</span>
</span><span class='line'><span class="cm">     2015-07-09 14:20:30.289 Pthread-多平台[97728:209415] =======3==&lt;NSThread: 0x7ffdf2b90220&gt;{number = 7, name = (null)}</span>
</span><span class='line'><span class="cm">     2015-07-09 14:20:30.289 Pthread-多平台[97728:209432] =======1==&lt;NSThread: 0x7ffdf2b8fdc0&gt;{number = 4, name = (null)}</span>
</span><span class='line'><span class="cm">     2015-07-09 14:20:30.289 Pthread-多平台[97728:209416] =======5==&lt;NSThread: 0x7ffdf0e015a0&gt;{number = 5, name = (null)}</span>
</span><span class='line'><span class="cm">     2015-07-09 14:20:30.289 Pthread-多平台[97728:209414] =======2==&lt;NSThread: 0x7ffdf0c313e0&gt;{number = 3, name = (null)}</span>
</span><span class='line'><span class="cm">     2015-07-09 14:20:30.289 Pthread-多平台[97728:209417] =======4==&lt;NSThread: 0x7ffdf0c314c0&gt;{number = 6, name = (null)}</span>
</span><span class='line'><span class="cm">     */</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>注意：我们可以通过maxConcurrentOperationCount来设置改队列可以开启的最大线程数，最小是1，当设置为0的时候，不执行队列中的任务，当为1的时候为GCD中的串行同步(并行同步，主队列异步，全局队列同步)一样效果。</code>
&mdash;&mdash;&mdash;&mdash;-至此NSOperation的基本用法差不多涉及了，下面在来看看NSOperation封装带来的好处
- 队列挂起，suspended这个属性可以控制当前线程队列的暂停和开启，在这里，已经默认你是对iOS多线程的任务有一定了解的，suspended为NO时，回执行完当前的NSOperation实例的任务，后面的任务不会在执行知道你开启</p>

<ul>
<li>队列挂起或开启如下。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'><span class="c1">//    NSOperationQueue</span>
</span><span class='line'><span class="c1">//    挂起</span>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;0--%d-----%@---&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1--%d-----%@---&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;2--%d-----%@---&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">//当执行一个任务的时候收到suspended为NO，就会执行完当前循环，停在当前任务。</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//完成一个点击事件就会改变suspended的状态</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">suspended</span> <span class="o">=</span> <span class="o">!</span><span class="nb">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">isSuspended</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>队列取消，把当前队列后面的NSOperation实例全部清除掉，相对于挂起，取消是不可逆的。
所以在系统自定义的NSOperation实例中，取消跟挂起取YES结果一样</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----1---%@---%d-&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">],</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----2---%@--%d--&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">],</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;----3---%@--%d--&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">],</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">queue</span> <span class="n">cancelAllOperations</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在自定义的NSOperation类中，当然可以把他看做一个普通的NSOperation实例对象，但是系统给NSOperation提供一个cancel属性，所以他的可控粒度更小，控制起来比较个性，要做到这一点，要在我们自定义类里面重写的main方法里面做功夫</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ETOperation</span><span class="p">.</span><span class="n">m</span>
</span><span class='line'><span class="c1">//这样就可以做到在任务里想停就马上停。</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%d---1-------%@&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="err">调用</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">touchesBegan</span><span class="p">:(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="nl">withEvent</span><span class="p">:(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:[[</span><span class="n">ETOpearation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">touchesEnded</span><span class="p">:(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="n">touches</span> <span class="nl">withEvent</span><span class="p">:(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="n">event</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">queue</span> <span class="n">cancelAllOperations</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>操作依赖，NSOperation的作用在一定程度上类似于GCD的栅栏队列(Barrier)和队列组，也就是后续步骤要在前面步骤的基础上才能执行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="k">__block</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>        <span class="n">j</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation_0</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">blockOperation_0</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">blockOperation</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">blockOperation</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">blockOperation_0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>上述代码没有什么实际意义，拿上面的一个需求吧，例如，下载图片，合成图片。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">__block</span> <span class="bp">UIImage</span> <span class="o">*</span> <span class="n">image1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">__block</span> <span class="bp">UIImage</span> <span class="o">*</span> <span class="n">image2</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">image1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://f.hiphotos.baidu.com/image/pic/item/d788d43f8794a4c2e882eb8b0df41bd5ac6e39e8.jpg&quot;</span><span class="p">]]];</span>
</span><span class='line'>        <span class="n">image2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://h.hiphotos.baidu.com/image/pic/item/ac6eddc451da81cbd668501c5666d01608243151.jpg&quot;</span><span class="p">]]];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation_0</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="nb">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">image1</span> <span class="nl">drawAsPatternInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">image2</span> <span class="nl">drawAsPatternInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)];</span>
</span><span class='line'>        <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>        <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">myView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">blockOperation_0</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">blockOperation</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">blockOperation</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">blockOperation_0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>操作监听，在NSOperation属性中，有一个属性@property (copy) void (^completionBlock)(void)可以在某个操作执行完成时，在执行一段代码，有很多需求也用到这个属性，例如图片的下载，如上，可以试着把上面的那段代码改写，这里就随便写一段简单的代码来展示操作监听的强大。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="k">__block</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>        <span class="n">j</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">blockOperation</span><span class="p">.</span><span class="n">completionBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">blockOperation</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>线程通信</h3>

<ul>
<li> 线程之间的通信，线程的通信，在一个进程中，线程往往不是鼓励存在的，多个线程之间需要经常进行通信</li>
<li><p> 线程间通信的体现</p>

<ul>
<li> 在一个线程传递数据给另外一个线程</li>
<li> 在一个线程中执行完成任务后，转到另一个线程继续执行任务</li>
</ul>
</li>
<li><p>NSThread的线程通信</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//这个方法是指在当前线程运行完后调到主线程里面运行</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span><span class="p">;</span>
</span><span class='line'><span class="c1">//这个方法是指在当前线程运行完后调用另外一个线程里面运行</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">onThread:</span><span class="p">(</span><span class="bp">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="nv">thr</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span>
</span><span class='line'><span class="err">```</span>
</span><span class='line'><span class="o">-</span> <span class="n">GCD</span><span class="err">的线程通信</span><span class="p">,</span><span class="n">GCD</span><span class="err">的线程通信十分简单，只是在代码块里面调用代码块，直接上代码吧。</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc
从子线程回到主线程
dispatch_async(
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行耗时的异步操作&hellip;
      dispatch_async(dispatch_get_main_queue(), ^{
        // 回到主线程，执行UI刷新操作
        });
});</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="nf">NSOperation</span><span class="err">的线程通信</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc
//回到主线程
[[NSOperationQueue mainQueue] addOperationWithBlock:^{</p>

<pre><code>    }];
</code></pre>

<p>//去子线程
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperationWithBlock:^{</p>

<pre><code>}];
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程(一)]]></title>
    <link href="http://etund.github.com/blog/2015/07/08/iosduo-xian-cheng-%5B%3F%5D/"/>
    <updated>2015-07-08T20:30:48+08:00</updated>
    <id>http://etund.github.com/blog/2015/07/08/iosduo-xian-cheng-[?]</id>
    <content type="html"><![CDATA[<h2>iOS多线程(一)</h2>

<h3>基本</h3>

<ul>
<li>实现方案：pthread - NSThread  - GCD  - NSOperation</li>
<li>Pthread

<ul>
<li>多平台，可移植</li>
<li>c语言，要程序员管理生命周期</li>
<li>创建</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//这里已经开启了多线程，直接在这里调用子线程想要调用的代码</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pramga</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;-------&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">btnClick:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class='line'><span class="kt">pthread_t</span> <span class="n">pthread</span><span class="p">;</span>
</span><span class='line'><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<ul>
<li>NSThread

<ul>
<li>面向对象，简单实用</li>
<li>创建</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="c1">//隐式创建并启动线程</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">threadRun</span><span class="p">:)</span> <span class="nl">toTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">withObject</span><span class="p">:</span><span class="s">@&quot;etund&quot;</span><span class="p">];</span>
</span><span class='line'><span class="err">或者</span>
</span><span class='line'><span class="c1">//创建线程并且启动线程</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span> <span class="nl">performSelectorInBackground</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">threadRun</span><span class="p">:)</span> <span class="nl">withObject</span><span class="p">:</span><span class="s">@&quot;etund&quot;</span><span class="p">];</span>
</span><span class='line'><span class="err">或者</span>
</span><span class='line'><span class="err">上述两个优点是可以快速的创建并启动线程，方便快捷，但是不能对线程进行多余属性的设置，而下面一种方法就可以对线程实例属性的设置，但是要记得要手动开启线程。</span>
</span><span class='line'>   <span class="bp">NSThread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">threadRun</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="s">@&quot;etund&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>GCD</h3>

<ul>
<li>听说全称是叫“牛逼的中枢调度器”，但是我还是喜欢叫大中央调度</li>
<li>纯C语言，有很多强大的函数</li>
<li>优势：(纯属板书)

<ul>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
</li>
<li>核心：清楚什么是任务，队列

<ul>
<li>串行与并行不能决定是否要开启新县城</li>
<li>并行表明具有创建新线程的能力，但不一定创建新线程</li>
</ul>
</li>
<li>常用GCD内容

<ul>
<li>串行同步（并行同步/全局队列同步）,由于串行同步，并行同步，以及全局队列同步都是不创建线程按顺序执行，所以归为一类来讲。（不开任何子线程，在主线程中执行）</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="c1">//串行</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;etund&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="c1">//并行</span>
</span><span class='line'><span class="c1">//dispatch_queue_t queue = dispatch_queue_create(&quot;etund&quot;, DISPATCH_QUEUE_CONCURRENT);</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---1&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@----2&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@----3&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="err">运行结果</span>
</span><span class='line'> <span class="mi">2015</span><span class="o">-</span><span class="mo">07</span><span class="o">-</span><span class="mi">08</span> <span class="mi">19</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">39.611</span> <span class="n">Pthread</span><span class="o">-</span><span class="err">多平台</span><span class="p">[</span><span class="mi">63090</span><span class="o">:</span><span class="mi">302902</span><span class="p">]</span> <span class="o">&lt;</span><span class="nl">NSThread</span><span class="p">:</span> <span class="mh">0x7fc79142c1d0</span><span class="o">&gt;</span><span class="p">{</span><span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">main</span><span class="p">}</span><span class="o">---</span><span class="mi">1</span>
</span><span class='line'> <span class="mi">2015</span><span class="o">-</span><span class="mo">07</span><span class="o">-</span><span class="mi">08</span> <span class="mi">19</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">39.612</span> <span class="n">Pthread</span><span class="o">-</span><span class="err">多平台</span><span class="p">[</span><span class="mi">63090</span><span class="o">:</span><span class="mi">302902</span><span class="p">]</span> <span class="o">&lt;</span><span class="nl">NSThread</span><span class="p">:</span> <span class="mh">0x7fc79142c1d0</span><span class="o">&gt;</span><span class="p">{</span><span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">main</span><span class="p">}</span><span class="o">----</span><span class="mi">2</span>
</span><span class='line'> <span class="mi">2015</span><span class="o">-</span><span class="mo">07</span><span class="o">-</span><span class="mi">08</span> <span class="mi">19</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">39.612</span> <span class="n">Pthread</span><span class="o">-</span><span class="err">多平台</span><span class="p">[</span><span class="mi">63090</span><span class="o">:</span><span class="mi">302902</span><span class="p">]</span> <span class="o">&lt;</span><span class="nl">NSThread</span><span class="p">:</span> <span class="mh">0x7fc79142c1d0</span><span class="o">&gt;</span><span class="p">{</span><span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">main</span><span class="p">}</span><span class="o">----</span><span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 串行异步 （开启一个子线程，在子线程中执行）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;etund&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---1&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---2&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---3&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*运行结果</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:25:37.811 Pthread-多平台[68041:316565] &lt;NSThread: 0x7fb35850fe30&gt;{number = 3, name = (null)}---1</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:25:37.811 Pthread-多平台[68041:316565] &lt;NSThread: 0x7fb35850fe30&gt;{number = 3, name = (null)}---2</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:25:37.811 Pthread-多平台[68041:316565] &lt;NSThread: 0x7fb35850fe30&gt;{number = 3, name = (null)}---3</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 并行异步（全局队列异步）虽然线程的执行顺序不一样，但是任务从队列里面拿出来放进线程的顺序是按照先进先出的这是根本，基础。（有几个任务，开启几个子线程，在各自的子线程中执行）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;etund&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---1&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---2&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---3&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="c1">//   虽然线程的执行顺序不一样，但是任务从队列里面拿出来放进线程的顺序是按照先进先出</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> *2015-07-08 19:27:46.060 Pthread-多平台[68694:318231] &lt;NSThread: 0x7f9a89c126b0&gt;{number = 4, name = (null)}---2</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:27:46.060 Pthread-多平台[68694:318230] &lt;NSThread: 0x7f9a8c211400&gt;{number = 5, name = (null)}---3</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:27:46.060 Pthread-多平台[68694:318171] &lt;NSThread: 0x7f9a89f9efe0&gt;{number = 3, name = (null)}---1</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 主队列异步,不开任何子线程，在主线程中运行，也对应了那句话，异步队列只是具有开启子线程的能力，但是不一定开子线程。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    主队列异步(不开线程)</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---1&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---2&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---3&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span> <span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:34:25.440 Pthread-多平台[70710:322816] &lt;NSThread: 0x7fe0d1418200&gt;{number = 1, name = main}---1</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:34:25.440 Pthread-多平台[70710:322816] &lt;NSThread: 0x7fe0d1418200&gt;{number = 1, name = main}---2</span>
</span><span class='line'><span class="cm"> 2015-07-08 19:34:25.440 Pthread-多平台[70710:322816] &lt;NSThread: 0x7fe0d1418200&gt;{number = 1, name = main}---3</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 主队列同步</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">gcdTest_2_4</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=-=-=-&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">//    主队列同步(阻塞)</span>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---1&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---2&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@---3&quot;</span><span class="p">,[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=-=-=-&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>至此，基本GCD队列已经被差不多就这样了，下面来一下有趣的用法
    - GCD队列组，有这么一个需求，你的一个步骤要在其他步骤完成之后才能完成，也就是后续步骤要依赖于前期步骤，这是GCD队列组以及Barrier队列(栅栏队列)不失为一个好办法，</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//GCD队列组方式</span>
</span><span class='line'>        <span class="c1">//    (线程组)(线程通讯)</span>
</span><span class='line'><span class="c1">//    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span>
</span><span class='line'>    <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">//    加载图片1</span>
</span><span class='line'>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://f.hiphotos.baidu.com/image/pic/item/d788d43f8794a4c2e882eb8b0df41bd5ac6e39e8.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">image1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="c1">//    加载图片2</span>
</span><span class='line'>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://h.hiphotos.baidu.com/image/pic/item/ac6eddc451da81cbd668501c5666d01608243151.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">image2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//    合并</span>
</span><span class='line'>    <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="nb">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">image1</span> <span class="nl">drawAsPatternInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">image2</span> <span class="nl">drawAsPatternInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>        <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>        <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>        <span class="c1">//GCD线程之间的通信</span>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">myView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//栅栏dispatch_barrier方式</span>
</span><span class='line'>        <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;etund&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span><span class="c1">//创建多个线程</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://f.hiphotos.baidu.com/image/pic/item/d788d43f8794a4c2e882eb8b0df41bd5ac6e39e8.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">image1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://h.hiphotos.baidu.com/image/pic/item/ac6eddc451da81cbd668501c5666d01608243151.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">image2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="nb">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">image1</span> <span class="nl">drawAsPatternInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">image2</span> <span class="nl">drawAsPatternInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>        <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>        <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">myView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>延迟加载</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 2秒后异步执行这里的代码...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>快速迭代，当我们不需要注重迭代的顺序，只需要快速获得子元素的时候，GCD的快速迭代为你提供了途径</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    (快速迭代)</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">subviews</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">subviews</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;---%zu---%@&quot;</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">2015-07-08 22:26:39.851 Pthread-多平台[972:17366] ---0---&lt;_UILayoutGuide: 0x7fd86b644e00; frame = (0 0; 0 20); hidden = YES; layer = &lt;CALayer: 0x7fd86b643ab0&gt;&gt;</span>
</span><span class='line'><span class="cm">2015-07-08 22:26:39.851 Pthread-多平台[972:17444] ---2---&lt;UIImageView: 0x7fd86b645ba0; frame = (100 100; 100 100); clipsToBounds = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x7fd86b643290&gt;&gt;</span>
</span><span class='line'><span class="cm">2015-07-08 22:26:39.851 Pthread-多平台[972:17435] ---1---&lt;_UILayoutGuide: 0x7fd86b6457b0; frame = (0 568; 0 0); hidden = YES; layer = &lt;CALayer: 0x7fd86b644040&gt;&gt;</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>once一次性代码（单例模式设计）,有时候我们需要用到单例模式做一些操作例如：传值时，就会用到单例设计模式，设计单例模式的方法很多，其中最重要的是要做到线程安全，而GCD就提供了这么一个结构体来保证在创建单例过程中的线程安全</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ETPerson</span><span class="p">.</span><span class="n">h</span>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="n">sharePerson</span><span class="p">;</span>
</span><span class='line'><span class="n">ETPerson</span><span class="p">.</span><span class="n">m</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ETPerson</span>
</span><span class='line'><span class="k">static</span> <span class="n">ETPerson</span> <span class="o">*</span><span class="n">_person</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharePerson</span><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceDispatch</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceDispatch</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ETPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_person</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">allocWithZone:</span><span class="p">(</span><span class="k">struct</span> <span class="bp">_NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceDispatch</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceDispatch</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_person</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">allocWithZone</span><span class="p">:</span><span class="n">zone</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_person</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_person</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="err">调用</span>
</span><span class='line'><span class="c1">//    onece(单例)</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@----%@------%@-------%@------%@-----%@&quot;</span><span class="p">,[[</span><span class="n">ETPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">],[[</span><span class="n">ETPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">],[</span><span class="n">ETPerson</span> <span class="k">copy</span><span class="p">],[</span><span class="n">ETPerson</span> <span class="k">copy</span><span class="p">],[</span><span class="n">ETPerson</span> <span class="n">sharePerson</span><span class="p">],[</span><span class="n">ETPerson</span> <span class="n">sharePerson</span><span class="p">]);</span>
</span><span class='line'>    <span class="cm">/*运行结果</span>
</span><span class='line'><span class="cm">     2015-07-08 23:26:57.292 Pthread-多平台[1350:37528] &lt;ETPerson: 0x7fc4bb4041c0&gt;----&lt;ETPerson: 0x7fc4bb4041c0&gt;------ETPerson-------ETPerson------&lt;ETPerson: 0x7fc4bb4041c0&gt;-----&lt;ETPerson: 0x7fc4bb4041c0&gt;</span>
</span><span class='line'><span class="cm">     */</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度剖析]]></title>
    <link href="http://etund.github.com/blog/2015/06/21/runloopshen-du-pou-xi/"/>
    <updated>2015-06-21T22:13:01+08:00</updated>
    <id>http://etund.github.com/blog/2015/06/21/runloopshen-du-pou-xi</id>
    <content type="html"><![CDATA[<h1>RunLoop</h1>

<h2>前言</h2>

<ul>
<li><p>RunLoop是iOS/OS开发中比较基础的一个概念，在苹果开发中用在事件处理，延迟加载，屏幕刷新等功能的处理，其实抛开语言，RunLoop是一个的架构模式，也就是RunLoop不仅仅局限于iOS开发。</p></li>
<li><p>网上有很多关于RunLoop的干货，但大多不怎么全，这位哥们的写的挺好的，挺详细的，基本上把要说的都说了，底层也研究的很细，本文基本上是转载他的，只是在它的基础上，基于我的知识水平补充了一些，<a href="http://www.cocoachina.com/ios/20150601/11970.html">原文</a></p></li>
<li><p>官方有已经有<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">关于RunLoop的官方文档</a>，英语的，不过网上已经有人把它翻译为中文了，大家可以去看看.</p></li>
</ul>


<!-- more -->


<h2>概念</h2>

<ul>
<li><p>简单来说RunLoop是线程的基本架构模式，架构模式，架构模式-重要的事情说三遍，然并卵，哈哈，具体怎么做呢，就是有事做事，没事睡觉，有事叫我，就这样，想看详细的自己看中文文档去，毕竟文档哪里已经写的好详细了，再板书就没意义了。</p></li>
<li><p>分类(获取)：苹果提供了两个途径来获取分别是Cocoe里面定义的NSRunLoop以及CoreFoundation里面定义的CFRunLoopRef。</p></li>
<li>CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的。</li>
<li>NSRunLoop提供了面向对象的API，但这些API不是线程安全的。</li>
<li>创建，苹果官方对CFRunLoopRef进行了开源，在这里<a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz">官方源码</a>下载就好，苹果官方不提供向我们平时那样子的新建对象的方法来获取NSRunLoop实例，但是可以通过[NSRunLoop getCurrentLoop]来创建，接下来看看具体是怎么创建的把,Show code！</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    全局字典，用来存放线程对应的RunLoop</span>
</span><span class='line'><span class="c1">//    key是线程，value是RunLoop实例，换言之线程与RunLoopRunLoop一一对应</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">CFMutableDictionaryRef</span> <span class="n">__CFRunLoops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">CFSpinLock_t</span> <span class="n">loopsLock</span> <span class="o">=</span> <span class="n">CFSpinLockInit</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 当t == 0 的时候，代表主线程</span>
</span><span class='line'>    <span class="n">CF_EXPORT</span> <span class="n">CFRunLoopRef</span> <span class="nf">_CFRunLoopGet0</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//        如果存进来的线程等于 0</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_equal</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">kNilPthreadT</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//            那么当前线程等于主线程</span>
</span><span class='line'>            <span class="n">t</span> <span class="o">=</span> <span class="n">pthread_main_thread_np</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="c1">//        给操作加锁</span>
</span><span class='line'>        <span class="n">__CFSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'><span class="c1">//        如果当前RunLoop没有为空，创建。</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__CFRunLoops</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">__CFSpinUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'>            <span class="n">CFMutableDictionaryRef</span> <span class="n">dict</span> <span class="o">=</span> <span class="n">CFDictionaryCreateMutable</span><span class="p">(</span><span class="n">kCFAllocatorSystemDefault</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kCFTypeDictionaryValueCallBacks</span><span class="p">);</span>
</span><span class='line'>            <span class="n">CFRunLoopRef</span> <span class="n">mainLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopCreate</span><span class="p">(</span><span class="n">pthread_main_thread_np</span><span class="p">());</span>
</span><span class='line'><span class="c1">//            把线程与RunLoop一一对应的存进字典</span>
</span><span class='line'>            <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">pthreadPointer</span><span class="p">(</span><span class="n">pthread_main_thread_np</span><span class="p">()),</span> <span class="n">mainLoop</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OSAtomicCompareAndSwapPtrBarrier</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__CFRunLoops</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRelease</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">mainLoop</span><span class="p">);</span>
</span><span class='line'>            <span class="n">__CFSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="c1">//        获取当前线程的RunLoop</span>
</span><span class='line'>        <span class="n">CFRunLoopRef</span> <span class="n">loop</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="n">CFDictionaryGetValue</span><span class="p">(</span><span class="n">__CFRunLoops</span><span class="p">,</span> <span class="n">pthreadPointer</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span><span class='line'>        <span class="n">__CFSpinUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'><span class="c1">//        如果不是主线程并且之前没有创建，也即是为空</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CFRunLoopRef</span> <span class="n">newLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopCreate</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'>            <span class="n">__CFSpinLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'>            <span class="n">loop</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="n">CFDictionaryGetValue</span><span class="p">(</span><span class="n">__CFRunLoops</span><span class="p">,</span> <span class="n">pthreadPointer</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//                把当前子线程和创建的RunLoop一一对应的存进字典</span>
</span><span class='line'>                <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">__CFRunLoops</span><span class="p">,</span> <span class="n">pthreadPointer</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">newLoop</span><span class="p">);</span>
</span><span class='line'>                <span class="n">loop</span> <span class="o">=</span> <span class="n">newLoop</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="c1">// don&#39;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span>
</span><span class='line'>            <span class="n">__CFSpinUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">newLoop</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_equal</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">()))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_CFSetTSD</span><span class="p">(</span><span class="n">__CFTSDKeyRunLoop</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">loop</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">_CFGetTSD</span><span class="p">(</span><span class="n">__CFTSDKeyRunLoopCntr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">_CFSetTSD</span><span class="p">(</span><span class="n">__CFTSDKeyRunLoopCntr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">PTHREAD_DESTRUCTOR_ITERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="n">__CFFinalizeRunLoop</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>上面是苹果开源的CFRunLoop中获取RunLoop的代码，简而言之就是，在调用这个方法要存进一个PThread(PThread提供了跨平台的管理多线程的API)，利用这个PThread作为全局字典中的key，并创建与之对应的RunLoop作为Value.RunLoop在我们获取的时候创建，不获取不创建，主线程的RunLoop在一开始就自动创建。<code>简而言之，线程与RunLoop一一对应</code></li>
</ul>


<h2>对外接口</h2>

<ul>
<li>在CoreFoundation里面关于RunLoop有5个类

<ul>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
</ul>
</li>
</ul>


<p><code>其中CFRunLoopModeRef类没有对外暴露，只是通过CFRunLoopRef接口进行了封装</code>
- 一个RunLoop包含若干个Mode,每个Mode又包含若干个source/Timer/Observer,如图。</p>

<p><img src="http://etund.github.com/images/blog/runloop/1432798883604537.png" alt="" /></p>

<ul>
<li><p>每次调用RunLoop的主函数时，只能指定其中一个Mode作为CurrentMode(可以通过这个属性获取当前的Mode),只能退出Loop,在重新指定一个Mode进入。在这里需要清楚的是，系统默认注册了5个Mode</p>

<ul>
<li>NSDefaultRunLoopMode:App默认Mode,当没有接收到ScrollView滚动是，主线程通常使用这个Mode</li>
<li><p>NSTrackingRunLoopMode:到接收到ScroolView或其子类的时候，主线程就会切换到这个模式下运行。</p></li>
<li><p>UIInitializationRunLoopMode：当App启动时使用的第一个Mode,当启动完成后不再使用。</p></li>
<li>NSRunLoopCommonModes，是一个tag,本质上不是一个Mode,默认NSDefaultRunLoopMode和NSTrackingRunLoopMode都绑定这个tag。(应用场景：有时候我们需要添加一个NSTimer在RunLoop,在这时需要制定一个Modes，现在的需求是:我们既要在默认模式下要监听，在滚动模式下也要监听，但只能制定一个模式，这是可以制定这个CommonMode)</li>
<li>GSEventReceiveRunLoopMode：接受系统内部的Mode,通常做不到。</li>
<li>处理不同事件使用不同的Mode，可以最大限度的把性能的最大化处理不同分类的事件，提高性能。</li>
</ul>
</li>
<li><p>CFRunLoopSourceRef：事件产生的地方，按照函数调用栈来分，Source的分类可以分为</p>

<ul>
<li>Source0：非基于Port的，只包含一个回调(函数指针)，他并不能主动触发事件。使用时，你需要先把这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(RunLoop)，然后再让它执行。</li>
<li>Source1：基于Port的，通过内核和其他线程通信分发的、系统事件。</li>
<li>这里的Port是线程间通信的一种方式，简而言之，如果两个线程之间想通信，可以对方的Port来通信。</li>
</ul>
</li>
<li>CFRunLoopTimerRef

<ul>
<li>基于时间触发器，当其加入RunLoop时，RunLoop会注册对应的时间点，当时间点到，RunLoop会被唤醒执行里面的回调。</li>
</ul>
</li>
<li><p>CFRunLoopObserverRef</p>

<ul>
<li>这是观察者，能够监听RunLoop的状态改变。</li>
<li>可以监听的时间点有以下几个。</li>
</ul>


<pre><code class="``objc">  /* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
  kCFRunLoopEntry = (1UL &lt;&lt; 0),//即将进入Loop
  kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//即将处理Timer
  kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),//即将处理Source
  kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//即将进入休眠
  kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//刚从休眠中唤醒
  kCFRunLoopExit = (1UL &lt;&lt; 7),//即将 退出Loop
  kCFRunLoopAllActivities = 0x0FFFFFFFU
};
</code></pre>

<ul>
<li>上面的Source/Timer/Observer被统称为mode item,一个item可以被同时加入多个mode。但一个item被重复加入同一个mode时不会有效果，如果一个item里面一个mode也没有，则RunLoop刚创建就被退出，不进入循环，这里在线程常驻的时候会讲到。</li>
</ul>
</li>
<li><p>CFRunLoop对外暴露的管理Mode的接口只有下面2个
<code>objc
CF_EXPORT SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);
CF_EXPORT void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode);
</code></p></li>
<li><p>Mode暴露管理的mode item的接口有下面几个</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRunLoopAddTimer</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRunLoopRemoveSource</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRunLoopRemoveObserver</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRunLoopRemoveTimer</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>你只能通过mode name来操作内部的mode,当你传入一个的mode name没有对应的mode.RunLoop会自动帮你创建对应的CFRunLoopModeRef。对于一个RunLoop来说，其内部的mode只能增加不能删除。</li>
</ul>


<h2>RunLoop的内部逻辑</h2>

<ul>
<li>RunLoop内部的逻辑大致如下</li>
</ul>


<p><img src="http://etund.github.com/images/blog/runloop/1432798974517485.png" alt="" /></p>

<ul>
<li>其内部代码整理如下</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// 用DefaultMode启动</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">CFRunLoopRun</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRunSpecific</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">,</span> <span class="mf">1.0e10</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 用指定的Mode启动，允许设置RunLoop超时时间</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">,</span> <span class="n">CFTimeInterval</span> <span class="n">seconds</span><span class="p">,</span> <span class="kt">Boolean</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">CFRunLoopRunSpecific</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">modeName</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">returnAfterSourceHandled</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// RunLoop的实现</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">CFRunLoopRunSpecific</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">modeName</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 首先根据modeName找到对应mode</span>
</span><span class='line'>    <span class="n">CFRunLoopModeRef</span> <span class="n">currentMode</span> <span class="o">=</span> <span class="n">__CFRunLoopFindMode</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">modeName</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">/// 如果mode里没有source/timer/observer, 直接返回。</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopModeIsEmpty</span><span class="p">(</span><span class="n">currentMode</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span>
</span><span class='line'>    <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopEntry</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 内部函数，进入loop</span>
</span><span class='line'>    <span class="n">__CFRunLoopRun</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">returnAfterSourceHandled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">Boolean</span> <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">retVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeTimers</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeSources</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">/// 执行被加入的block</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 4. RunLoop 触发 Source0 (非port) 回调。</span>
</span><span class='line'>            <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopDoSources0</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">stopAfterHandle</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">/// 执行被加入的block</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">__Source0DidDispatchPortLastTime</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="kt">Boolean</span> <span class="n">hasMsg</span> <span class="o">=</span> <span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">dispatchPort</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">hasMsg</span><span class="p">)</span> <span class="k">goto</span> <span class="n">handle_msg</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sourceHandledThisLoop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span>
</span><span class='line'>            <span class="c1">/// ? 一个基于 port 的Source 的事件。</span>
</span><span class='line'>            <span class="c1">/// ? 一个 Timer 到时间了</span>
</span><span class='line'>            <span class="c1">/// ? RunLoop 自身的超时时间到了</span>
</span><span class='line'>            <span class="c1">/// ? 被其他什么调用者手动唤醒</span>
</span><span class='line'>            <span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">waitSet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">livePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">mach_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">MACH_RCV_MSG</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span> <span class="c1">// thread wait for receive msg</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopAfterWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 收到消息，处理消息。</span>
</span><span class='line'>            <span class="nl">handle_msg</span><span class="p">:</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">msg_is_timer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">__CFRunLoopDoTimers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">mach_absolute_time</span><span class="p">())</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 9.2 如果有dispatch到main_queue的block，执行block。</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg_is_dispatch</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span>
</span><span class='line'>            <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRunLoopSourceRef</span> <span class="n">source1</span> <span class="o">=</span> <span class="n">__CFRunLoopModeFindSourceForMachPort</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">livePort</span><span class="p">);</span>
</span><span class='line'>                <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopDoSource1</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">source1</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">sourceHandledThisLoop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">mach_msg</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="n">MACH_SEND_MSG</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 执行加入到Loop的block</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">sourceHandledThisLoop</span> <span class="o">&amp;&amp;</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// 进入loop时参数说处理完事件就返回。</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunHandledSource</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// 超出传入参数标记的超时时间了</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunTimedOut</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopIsStopped</span><span class="p">(</span><span class="n">runloop</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// 被外部调用者强制停止了</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopModeIsEmpty</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// source/timer/observer一个都没有了</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunFinished</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retVal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 10. 通知 Observers: RunLoop 即将退出。</span>
</span><span class='line'>    <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopExit</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>可以看到，实际上 RunLoop就是这样一个函数，其内部是一个 do-while 循环。当你调用CFRunLoopRun()时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</li>
</ul>


<h2>底层实现</h2>

<ul>
<li>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构</li>
</ul>


<p><img src="http://etund.github.com/images/blog/runloop/1432799001829463.png" alt="" /></p>

<ul>
<li>苹果官方将整个系统大致划分为上述4个层次：

<ul>
<li>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</li>
<li>应用框架层即开发人员接触到的 Cocoa 等框架。</li>
<li>核心框架层包括各种核心框架、OpenGL 等内容。</li>
<li>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在<a href="http://opensource.apple.com/">苹果开源源码</a>里找到。</li>
</ul>
</li>
<li>我们在深入看一下 Darwin 这个核心的架构：</li>
</ul>


<p><img src="http://etund.github.com/images/blog/runloop/1432799031419231.png" alt="" /></p>

<pre><code>- 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核
- XNU 内核的内环被称作Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。
- BSD 层可以看作围绕Mach层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。
- IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。
- Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在Mach中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为"对象"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。"消息"是Mach中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。
- Mach 的消息定义是在头文件的，很简单：

```objc
    typedef struct {
  mach_msg_header_t header;
  mach_msg_body_t body;
    } mach_msg_base_t;

typedef struct {
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_t msgh_remote_port;
  mach_port_t msgh_local_port;
  mach_port_name_t msgh_voucher_port;
  mach_msg_id_t msgh_id;
    } mach_msg_header_t;

```

- 一条 Mach 消息实际上就是一个二进制数据包(BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port。
</code></pre>

<ul>
<li><p> 发送和接受消息是通过同一个API进行的，其option标记了消息传递的方向：</p>

<pre><code class="objc">mach_msg_return_t mach_msg(
mach_msg_header_t *msg,
mach_msg_option_t option,
mach_msg_size_t send_size,
mach_msg_size_t rcv_size,
mach_port_name_t rcv_name,
mach_msg_timeout_t timeout,
mach_port_name_t notify);
</code></pre>

<ul>
<li>为了实现消息的发送和接收，mach_msg()函数实际上是调用了一个 Mach 陷阱(trap)，即函数ach_msg_trap()，陷阱这个概念在Mach中等同于系统调用。当你在用户态调用mach_msg_trap()时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</li>
</ul>
</li>
</ul>


<p><img src="http://etund.github.com/images/blog/runloop/1432799057446598.png" alt="" /></p>

<pre><code>- RunLoop 的核心就是一个mach_msg()(见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在App静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方
- 当 RunLoop进行回调时，一般都是通过一个很长的函数调用出去 (call out),当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：

```objc


{
/// 1. 通知Observers，即将进入RunLoop
/// 此处有Observer会创建AutoreleasePool:                         _objc_autoreleasePoolPush();
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION_    _(kCFRunLoopEntry);
do {

    /// 2. 通知 Observers: 即将触发 Timer 回调。
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
    /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

    /// 4. 触发 Source0 (非基于port的) 回调。
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

    /// 6. 通知Observers，即将进入休眠
    /// 此处有Observer释放并新建AutoreleasePool:     _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);

    /// 7. sleep to wait msg.
    mach_msg() -&gt; mach_msg_trap();


    /// 8. 通知Observers，线程被唤醒
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);

    /// 9. 如果是被Timer唤醒的，回调Timer
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);

    /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);

    /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);


} while (...);

/// 10. 通知Observers，即将退出RunLoop
/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
</code></pre>

<p>}
    ```</p>

<h2>RunLoop 的实际应用举例</h2>

<h6>AutoreleasePool</h6>

<ul>
<li><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p></li>
<li><p>第一个 Observer监视的事件是Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush()创建自动释放池。其order是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p></li>
<li><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop)时调用_objc_autoreleasePoolPop() 来释放自动释放池。这个Observer的order是2147483647，优先级最低，保证其释放池子发生在其他所有回调之后</p></li>
<li><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p></li>
</ul>


<h6>事件响应</h6>

<ul>
<li><p>苹果注册了一个Source1(基于machport的)用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p></li>
<li><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由IOKit.framework 生成一个 IOHIDEvent事件并由SpringBoard接收。这个过程的详细情况可以参考这里。SpringBoard只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用macport转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。</p></li>
<li><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如UIButton点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p></li>
</ul>


<h6>手势识别</h6>

<ul>
<li><p>当上面的 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用 Cancel 将当前的touchesBegin/Move/End系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p></li>
<li><ul>
<li>苹果注册了一个 Observer 监测 BeforeWaiting(Loop即将进入休眠) 事件，这个Observer的回调函数是_UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行GestureRecognizer的回调。</li>
</ul>
</li>
<li><p>当有 UIGestureRecognizer的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p></li>
</ul>


<h6>界面更新</h6>

<ul>
<li><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 层次时，或者手动调用了UIView/CALayer的setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer就被标记为待处理，并被提交到一个全局的容器去。</p></li>
<li><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p></li>
<li><p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的UIView/CAlayer以执行实际的绘制和调整，并更新 UI 界面。</p></li>
<li><p>这个函数内部的调用栈大概是这样的：</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><span class="p">()</span>
</span><span class='line'>    <span class="nl">QuartzCore</span><span class="p">:</span><span class="n">CA</span><span class="o">::</span><span class="n">Transaction</span><span class="o">::</span><span class="nl">observer_callback</span><span class="p">:</span>
</span><span class='line'>        <span class="n">CA</span><span class="o">::</span><span class="n">Transaction</span><span class="o">::</span><span class="n">commit</span><span class="p">();</span>
</span><span class='line'>            <span class="n">CA</span><span class="o">::</span><span class="n">Context</span><span class="o">::</span><span class="n">commit_transaction</span><span class="p">();</span>
</span><span class='line'>                <span class="n">CA</span><span class="o">::</span><span class="n">Layer</span><span class="o">::</span><span class="n">layout_and_display_if_needed</span><span class="p">();</span>
</span><span class='line'>                    <span class="n">CA</span><span class="o">::</span><span class="n">Layer</span><span class="o">::</span><span class="n">layout_if_needed</span><span class="p">();</span>
</span><span class='line'>                        <span class="p">[</span><span class="bp">CALayer</span> <span class="n">layoutSublayers</span><span class="p">];</span>
</span><span class='line'>                            <span class="p">[</span><span class="bp">UIView</span> <span class="n">layoutSubviews</span><span class="p">];</span>
</span><span class='line'>                    <span class="n">CA</span><span class="o">::</span><span class="n">Layer</span><span class="o">::</span><span class="n">display_if_needed</span><span class="p">();</span>
</span><span class='line'>                        <span class="p">[</span><span class="bp">CALayer</span> <span class="n">display</span><span class="p">];</span>
</span><span class='line'>                            <span class="p">[</span><span class="bp">UIView</span> <span class="n">drawRect</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h6>定时器</h6>

<ul>
<li><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer注册到RunLoop后，RunLoop会为其重复的时间点注册好事件。例如10:00,10:10,10:20这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p></li>
<li><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果10:10时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p></li>
<li><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook开源的AsyncDisplayLink就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p></li>
<li><p>解决方案:如果有某些需求或者有强迫症的同学一定要做到时刻准确，那么可以用GCD的定时器来实现。</p></li>
</ul>


<h6>PerformSelecter(利用RunLoop常驻线程)</h6>

<ul>
<li><p>当调用 NSObject的performSelecter:afterDelay:后，实际上其内部会创建一个 Timer 并添加到当前线程的RunLoop中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p></li>
<li><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有RunLoop该方法也会失效。</p>

<h6>GCD</h6></li>
<li><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p></li>
<li><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调</p></li>
<li><p><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()里执行这个 block。但这个逻辑仅限于dispatch到主线程，dispatch到其他线程仍然是由 libDispatch 处理的。</p></li>
</ul>


<h6>关于网络请求</h6>

<ul>
<li>iOS 中，关于网络请求的接口自下至上有如下几层:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFSocket</span>
</span><span class='line'><span class="n">CFNetwork</span>       <span class="o">-&gt;</span><span class="n">ASIHttpRequest</span>
</span><span class='line'><span class="bp">NSURLConnection</span> <span class="o">-&gt;</span><span class="n">AFNetworking</span>
</span><span class='line'><span class="bp">NSURLSession</span>    <span class="o">-&gt;</span><span class="n">AFNetworking2</span><span class="p">,</span> <span class="n">Alamofire</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><ul>
<li><p>CFSocket 是最底层的接口，只负责 socket 通信。</p></li>
<li><p>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</p></li>
<li><p>NSURLConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层</p></li>
<li><p>NSURLSession 是iOS7中新增的接口，表面上是和NSURLConnection 并列的，但底层仍然用到了</p></li>
</ul>
</li>
<li><p>下面主要介绍下 NSURLConnection 的工作过程。</p>

<ul>
<li><p>通常使用 NSURLConnection 时，你会传入一个Delegate，当调用了 [connection start]后，这个Delegate会不停收到事件回调。实际上，<code>start这个函数的内部会会获取CurrentRunLoop</code>，然后在其中的DefaultMode添加了4个 Source0(即需要手动触发的Source)。CFMultiplexerSource是负责各种 Delegate回调的，CFHTTPCookieStorage是处理各种Cookie 的。</p></li>
<li><p>当开始网络传输时，我们可以看到NSURLConnection创建了两个新线程：com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中 CFSocket程是处理底层socket连接的。NSURLConnectionLoader 这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p></li>
</ul>
</li>
</ul>


<p><img src="http://etund.github.com/images/blog/runloop/1432799200369980.png" alt="" /></p>

<ul>
<li>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层CFSocket的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource等Source0发送通知，同时唤醒 Delegate 线程的RunLoop来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对Delegate执行实际的回调。</li>
</ul>


<h6>AFNetworking</h6>

<ul>
<li>AFURLConnectionOperation这个类是基于NSURLConnection构建的，其希望能在后台线程接收Delegate回调。为此AFNetworking独创建了一个线程，并在这个线程中启动了一个 RunLoop：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">networkRequestThreadEntryPoint:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">__unused</span> <span class="n">object</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="nl">setName</span><span class="p">:</span><span class="s">@&quot;AFNetworking&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">runLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="nl">addPort</span><span class="p">:[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">]</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="bp">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="n">networkRequestThread</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="bp">NSThread</span> <span class="o">*</span><span class="n">_networkRequestThread</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">oncePredicate</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oncePredicate</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_networkRequestThread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkRequestThreadEntryPoint</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_networkRequestThread</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_networkRequestThread</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>RunLoop 启动前内部必须要有至少一个item</code>，所以 AFNetworking在[runLooprun]之前先创建了一个新的NSMachPort 添加进去了。通常情况下，调用者需要持有这个NSMachPort(mach_port) 并在外部线程通过这个port发送消息到loop内；但此处添加 port 只是为了让RunLoop不至于退出，并没有用于实际的发送消息</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">lock</span> <span class="n">lock</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="n">isCancelled</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">cancelConnection</span><span class="p">)</span> <span class="nl">onThread</span><span class="p">:[[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="n">networkRequestThread</span><span class="p">]</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span> <span class="nl">modes</span><span class="p">:[</span><span class="nb">self</span><span class="p">.</span><span class="n">runLoopModes</span> <span class="n">allObjects</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="n">isReady</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">AFOperationExecutingState</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">operationDidStart</span><span class="p">)</span> <span class="nl">onThread</span><span class="p">:[[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="n">networkRequestThread</span><span class="p">]</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span> <span class="nl">modes</span><span class="p">:[</span><span class="nb">self</span><span class="p">.</span><span class="n">runLoopModes</span> <span class="n">allObjects</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">lock</span> <span class="n">unlock</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>注意<code>RunLoop 启动前内部必须要有至少一个item</code>，虽然Obsever也是item的一种，但是只会等待Timer和Source ，Timer是因为有回调，Source是会接收事件，所以当RunLoop里面有Timer或者Source的时候，RunLoop会等待里面的item(除Obsever以外)<code>主动</code>给他发消息，然后Oberver<code>被动</code>的接收RunLoop发送过来的消息，亦即是说，能主动给RunLoop发消息的item会让RunLoop跑起来并且不退出。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreateWithHandler</span><span class="p">(</span><span class="n">CFAllocatorGetDefault</span><span class="p">(),</span> <span class="n">kCFRunLoopAllActivities</span><span class="p">,</span> <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="n">run</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当需要这个后台线程执行任务时，AFNetworking 通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</li>
</ul>


<h6>AsyncDisplayKit</h6>

<ul>
<li><p>AsyncDisplayKit是Facebook推出的用于保持界面流畅性的框架，其原理大致如下：</p>

<ul>
<li><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p></li>
<li><p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作</p></li>
<li><p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p></li>
<li><p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p></li>
</ul>
</li>
<li><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p></li>
<li><p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p></li>
<li><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p></li>
</ul>


<h6>常驻线程</h6>

<ul>
<li>有这么一个需求，我们要在子线程中没接收一个事件就调用一次方法。但是子线程在完成任务后就销毁，全局变量强引用？试试</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSThread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="s">@&quot;etund&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="kr">thread</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;-----%p&quot;</span><span class="p">,[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="nl">onThread</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="kr">thread</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;==========&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;------------------&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果不能执行，这里要清楚线程的5个状态，新建，就绪，运行，阻塞，死亡。意思就是就算你是强引用一个子线程，但是他执行完任务就已经处于死亡状态了，只是他还存储在内存，`那么现在分析一下。</p>

<ul>
<li>想在子线程中不断执行任务，必须保证子线不处于死亡状态</li>
<li>但是子线程执行完一次任务就进入死亡状态</li>
<li><p>那我们可以把线程停留在进入死亡状态之前，这里可以用RunLoop</p></li>
<li><p>我们可以在线程初始化的时候执行的方法中给他创建一个运行时RunLoop,这是他就可以不断接收source，也就是这样</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:[[</span><span class="bp">NSPort</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span> <span class="c1">// 1</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>注意：上面第一行代码必须加上，因为一个RunLoop里面必须有至少一个item(Obsever除外)</code></p>

<h6>GCD定时器</h6>

<ul>
<li>有这么一个需求，需要这么一个定时器，误差几乎为0的定时器，但是无论是NSTimer还是CGDisplayLink都会有误差，而且误差都比较大，这是我们可以用GCD来实现定时器，实际上，上面已经说了，RunLoop底层也是调用GCD的source来实现NSTimer的，只是NSTimer还受mode的影响，下面来看看怎么用GCD实现</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    获取队列</span>
</span><span class='line'>    <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span><span class='line'><span class="c1">//    创建定时器</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
</span><span class='line'><span class="c1">//    设置定时器属性(什么时候开始，间隔多大)</span>
</span><span class='line'><span class="c1">//    定义开始时间</span>
</span><span class='line'>    <span class="kt">dispatch_time_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">));</span>
</span><span class='line'><span class="c1">//    定义时间间隔</span>
</span><span class='line'>    <span class="kt">uint64_t</span> <span class="n">interver</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>
</span><span class='line'><span class="c1">//    设置开始时间和时间间隔</span>
</span><span class='line'>    <span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span><span class="n">interver</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="c1">//    设置回调</span>
</span><span class='line'>    <span class="n">dispatch_source_set_event_handler</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;==================&quot;</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="c1">//        dispatch_cancel(self.timer);</span>
</span><span class='line'><span class="c1">//        self.timer = nil;</span>
</span><span class='line'><span class="c1">//    取消定时器</span>
</span><span class='line'><span class="c1">//    启动定时器</span>
</span><span class='line'>    <span class="n">dispatch_resume</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百思不得姐-项目总结(五)]]></title>
    <link href="http://etund.github.com/blog/2015/02/25/bai-si-bu-de-jie-xiang-mu-zong-jie-wu/"/>
    <updated>2015-02-25T19:50:39+08:00</updated>
    <id>http://etund.github.com/blog/2015/02/25/bai-si-bu-de-jie-xiang-mu-zong-jie-wu</id>
    <content type="html"><![CDATA[<h3>功能模块实现(部分)</h3>

<h5>自定义UITextView</h5>

<ul>
<li>添加内容输入框。

<ul>
<li>内嵌</li>
<li>自定义UITextView

<ul>
<li>占位字符</li>
</ul>
</li>
<li>监听textView的输入值，用于去除占位字符，不能从外面监听，这是可以在内部通过通知的方式来监听。</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>细节处理与功能扩展</p>

<ul>
<li>如何动态监测占位字符的改变。</li>
<li>如何动态监测文字大小与颜色。

<ul>
<li><code>setNeedsLayout</code>与<code>setNeedsDisplay</code>的区别

<ul>
<li><code>setNeedsLayout</code>：会在恰当的时刻调用layoutSubviews方法</li>
<li><code>setNeedsDisplay</code>：会在恰当的时刻自动调用drawRect:方法</li>
<li><code>但是上面两个方法在一些操作上有些功能重复</code></li>
<li>想使用KVC来修改该对象的值，就要用该对象来调用KVC
<code>layoutIfNeeded</code>强制布局</li>
</ul>
</li>
</ul>
</li>
<li>如果一进来UITextView就有值呢？(包括有属性的文字与无属性的文字)</li>
</ul>
</li>
<li><p><code>监听UITextView内容的改变用通知，监听UITextField的改变用代理。</code></p></li>
<li>如何在键盘上添加视图

<ul>
<li>方法一

<ul>
<li>添加键盘监听</li>
<li>将view添加到键盘视图上</li>
<li>平移视图</li>
<li>键盘下降视图脱落，添加到主视图上。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h5>标签编辑界面</h5>

<ul>
<li>思路

<ul>
<li>先添加一个UITextField</li>
</ul>
</li>
<li>用UITextField还是UITextView?

<ul>
<li>由于标签比较短，下面还要添加一个按钮，前面要添加UIButton.</li>
<li>那么我们的TextField需要什么功能？

<ul>
<li>占位字符，光标。</li>
<li>实时更新UITextField的宽度。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何触发确认事件</p>

<ul>
<li>包括字符:逗号,空格,回车以及点击下面的标记按钮</li>
<li>接收键盘return键，delete键</li>
</ul>
</li>
<li><p>由于重写UINavigationViewController后不能使用右滑来返回上一层，这是可以讲</p></li>
<li><p>设置一个代理为空。</p></li>
<li><p>数据回显，也就是界面传值:无非四种:block 代理，通知，单例,意思是如何让一个界面的数据在上一个界面显示。</p>

<ul>
<li>这里用block</li>
</ul>
</li>
<li>如何解决界面会跳的时候键盘覆盖原来的控件。

<ul>
<li>这是由于添加键盘监听与设置第一响应者和注销第一响应者的顺序不对。</li>
<li>在注册键盘弹出的时候要注意添加监听和去除监听前后，也就是说，在成为添加键盘监听之后注册第一响应者，在去除键盘监听之前注销第一响应者。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百思不得姐-项目总结(四)]]></title>
    <link href="http://etund.github.com/blog/2015/02/24/bai-si-bu-de-jie-xiang-mu-zong-jie-si/"/>
    <updated>2015-02-24T19:47:07+08:00</updated>
    <id>http://etund.github.com/blog/2015/02/24/bai-si-bu-de-jie-xiang-mu-zong-jie-si</id>
    <content type="html"><![CDATA[<h3>哪些网上找不到的经验(二)</h3>

<ul>
<li>将约束对象翻转

<ul>
<li>这样做可以让父控件随着子控件的变化而变化，而不是子控件随着父控件的变化而变化。</li>
</ul>
</li>
<li>placeholderlabel是懒加载的。

<pre><code>  - 所以利用KVC设置placeholderlabel的颜色属性的时候要placeholderlabel是否为空。
</code></pre></li>
<li>如果我们的控件从xid加载

<ul>
<li>可以在layoutsubview方法里面设置控件尺寸</li>
<li>排布子控件不管是从xib加载还是代码加载都不受控制，可以在layoutsubview里面设置</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li>监听键盘属性变化的时候可以把键盘先退出在重新加载

<ul>
<li>对于监听的添加，以及主动设置第一响应者和注销第一响应者的时候要注意，在view出现的时候添加监听，在消失的时候去除监听，在在监听的去除和添加之间注册和注销第一响应者。也就是在监听添加之后注册第一响应者，在监听去除之前注销第一响应者。</li>
</ul>
</li>
<li>如何在控制器的TabBar中添加按钮

<ul>
<li>可以用KVC替换TabBar然后在TabBar里面处理控件尺寸</li>
</ul>
</li>
<li>如何让图片与文字不受渲染

<ul>
<li>图片可以用[image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]来设置</li>
<li>文字属性可以在initialize方法里面设置，有Appearance宏的属性都可以统一设置</li>
</ul>
</li>
<li>为什么在layoutSubviews里面调用dipatch_once会失败

<ul>
<li>由于static关键字</li>
</ul>
</li>
<li>当同时多次点击添加按钮的时候会出现多次添加控制器

<ul>
<li>这是动画的造成的bug，(参考我的另外一篇博客，UINavigation日常)</li>
</ul>
</li>
<li>返回数据照片会使cell的tableView变化

<ul>
<li>只要设置了placeholder图片返回的图片绝对不会变化</li>
</ul>
</li>
<li>如何解决网络慢带来的问题

<ul>
<li>在每次点击的时候马上刷新数据</li>
</ul>
</li>
<li>让用户不要一直发请求

<ul>
<li>在分类里面把数据存储起来，判断是否要发请求。</li>
</ul>
</li>
<li>下拉刷新

<ul>
<li>由于刷新，所以每次刷新要去服务器取首页数据，把以前的数据清除掉。</li>
<li>由于每次都要上拉/下拉刷新，所以不需要判断是否有数据</li>
<li>由于每次都是要点击到其他页面才下拉刷新，所以原则上是不需要判断当前的传进去的参数与self的参数是否一致，但是以防万一数据传输过慢还是加上好。</li>
<li>不用每次刷新右控件都去检查上拉刷新</li>
<li>但是右边每次reloadData的时候都要检查是否已经加载完</li>
</ul>
</li>
<li>如何让TextField的文字显示为白色。

<ul>
<li> 可以通过attributePlaceHolder来实现</li>
<li> 可以通过kvc来实现</li>
</ul>
</li>
<li>如何让tableView显示在窗口的中间。

<ul>
<li>可以设置contentInset</li>
</ul>
</li>
<li>如何解决cell重用图片重叠的问题

<ul>
<li>原因不详：</li>
<li>解决方法，在每次添加imageView的时候移除出父控件就好。</li>
<li>每种数据样式都要把其他样式的图片给隐藏掉。</li>
</ul>
</li>
<li>如何解决刷新的时候上拉与下拉同时进行？

<ul>
<li>可以保证下拉和下拉只有一个进行，在下拉之前停了上拉，在下拉之前停掉上拉。</li>
</ul>
</li>
<li>如何快速设置已经有背景图片的按钮的大小

<ul>
<li>把button的大小设为背景图片的大小即可。</li>
<li>button.currentImage</li>
</ul>
</li>
<li>如何解决界面会跳的时候键盘覆盖原来的控件。

<ul>
<li>这是由于添加键盘监听与设置第一响应者和注销第一响应者的顺序不对。</li>
<li>在注册键盘弹出的时候要注意添加监听和去除监听前后，也就是说，在成为添加键盘监听之后注册第一响应者，在去除键盘监听之前注销第一响应者。</li>
</ul>
</li>
<li>建议用数组来代替if-else,表驱动法</li>
<li>tabelView不分组的问题？tableView分组一定要设置grop样式吗？

<ul>
<li>实现tableView的代理方法viewForHeaderInSection，要向这个方法有效，必须实现heightForHeaderInSection或者设置tableView的样式为group。</li>
</ul>
</li>
<li>如何不占内存的给项目添加圆角？

<ul>
<li>利用画图知识。</li>
</ul>
</li>
<li>用pop框架做动画，在开始之前view会默认处于默认位置。</li>
<li>换肤

<ul>
<li>设计模式

<ul>
<li>plist - 皮肤文件夹 - plist - 图片</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百思不得姐-项目总结(三)]]></title>
    <link href="http://etund.github.com/blog/2015/02/23/bai-si-bu-de-jie-xiang-mu-zong-jie-san/"/>
    <updated>2015-02-23T19:26:47+08:00</updated>
    <id>http://etund.github.com/blog/2015/02/23/bai-si-bu-de-jie-xiang-mu-zong-jie-san</id>
    <content type="html"><![CDATA[<h3>哪些网上找不到的经验(一)</h3>

<ul>
<li>[UIColor colorWithPatternImage:]设置颜色跟图片一致</li>
<li>属性后面有Appearance宏，都可以通过Appearance统一设置，例如：UITabarItem</li>
<li>在分类中声明Property，只会声明方法声明，不会生成方法的实现和下划线属性。</li>
<li>用imageView的initWithImage图片尺寸会与imageView一样</li>
<li>如果navbarItem里面是文件，那么item接受事件，如果是Button，那么改button接收事件</li>
<li>按住Option加回车，UILabel可以换行</li>
</ul>


<!-- more -->


<ul>
<li>判断是否第一次上拉刷新是否时已经下载完了- - 在另外一个请求发送之前把上一次请求取消

<ul>
<li>调用[self.manager.tasks makeObjectsPerformSelector:@selector(cancel)];</li>
</ul>
</li>
<li>cell空出间隔

<ul>
<li>重写cell的setFrame的值，在本身的身上加上对应的空格。</li>
<li>自定义UIView</li>
</ul>
</li>
<li>如果不想别人修改我们的frame，我们可以重写setFrame和setbounds方法,例如一些控件：UISegument。</li>
<li>从iOS7开始不再通过Application来控制状态栏，而是通过控制器来控制。

<ul>
<li>默认是通过控制器来控制状态栏的，但是可以在配置文件里面重新设置。</li>
</ul>
</li>
<li>如果指针指向数组的首元素吧指针当做数组来使用。</li>
<li>滚动条内边距

<ul>
<li> 设置tableView的self.tableView.separatorInset方法。</li>
</ul>
</li>
<li>(MJExtension)header的autoChangeAlpha属性可以设置它自动改变透明度，这样适用于我们上部控件是透明的而遮盖不了后面的header的问题。</li>
<li>没初始化的NSInteger为0</li>
<li>如果把系统帮你生成的set方法和get方法重写，会报错，因为它不会帮你生产下划线属性。

<ul>
<li>如果是readonly的，重写get方法后，也不会帮我们自动生成下划线属性，</li>
<li>简而言之，如果把property默认帮你实现的方法都重写了，那么，好吧，你那么厉害，私有属性也自己写咯，property如是说。</li>
</ul>
</li>
<li>当属性与返回数据的名字不一样的时候(MJExtension)

<ul>
<li>一般做法是在属性的实现方法做重写+ (NSDictionary *)replacedKeyFromPropertyName;方法</li>
</ul>
</li>
<li>可以在xib里面给按钮的title和imgae之间添加间隔

<ul>
<li>利用contentEdginset</li>
</ul>
</li>
<li>对于UIImageView的布局属性

<ul>
<li>fit保证看到图片全部，按照原来的宽高比进行缩放</li>
<li>fill会缩小到宽度或者高度跟imageView一样为止</li>
</ul>
</li>
<li>如果遇到要不断更改第三方框架，最好是新建一个类来继承第三方框架类。

<ul>
<li>例如进度条框架。</li>
</ul>
</li>
<li>进度条负号解决，直接替换掉-号</li>
<li>sdWebImage的下载进度是用字典存放的，key是url，value是下载operation，所以不会重复加载</li>
<li>如何保证在cell循环的时候，进度值的问题</li>
<li>把操作存储起来</li>
<li>代码实现</li>
</ul>


<pre><code class="objc"></code></pre>

<ul>
<li>版本号：0.0.0 大版本号， 功能版本号，bug版本号</li>
<li>(项目打包)第三方框架图片资源依赖

<ul>
<li>放在一个文件夹里面，后缀名是bundle</li>
<li>当加载资源的时候加上文件夹路径</li>
</ul>
</li>
<li>如何做透明动画过程中而后面的画面不能跟后面的界面交互，问题的起因是由于当我们做动画的时候要让整个view都不能接收点击事件，但我们不能接收点击事件的时候后面的controller就会接受事件，这不是我们想要的。(facebook的框架)

<ul>
<li>我们也可以让view的所有子控件在做动画过程中全部调用一个方法(不与用户交互),就可以把在控件做动画的时候后面的view后滑动的bug</li>
<li>做透明界面可以用View跟窗口</li>
<li>如何挡住状态栏，可以参考Window的级别
-sd_image有按钮专用的图片下载方法</li>
<li>给按钮设置image的时候，用专用的sd_image方法</li>
</ul>
</li>
<li>让button文字居中显示

<ul>
<li>btn.titleLabel.textAlignment = NSTextAlignmentCenter;</li>
<li>图片居中</li>
<li>内容居中 contenViewMode</li>
<li>水平居中 UIControlContentHorizontalAlignment</li>
<li>垂直居中 UIControlContentVerticalAlignment</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百思不得姐-项目总结(二)]]></title>
    <link href="http://etund.github.com/blog/2015/02/21/bai-si-bu-de-jie-xiang-mu-zong-jie-er/"/>
    <updated>2015-02-21T19:08:55+08:00</updated>
    <id>http://etund.github.com/blog/2015/02/21/bai-si-bu-de-jie-xiang-mu-zong-jie-er</id>
    <content type="html"><![CDATA[<h3>小技巧(二)</h3>

<h4>双击菜单栏回到顶部？点击屏幕顶部回到最上面？</h4>

<ul>
<li><p>在整个应用启动的时候在应用顶部添加一个window用于点击，然后再监听这个window的点击事件。</p></li>
<li><p>自己自顶一个而一个类，继承window或者NSObject都行，然后定义一个window_成员变量。</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">window_</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIWindow</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">window_</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETScreenW</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">window_</span><span class="p">.</span><span class="n">windowLevel</span> <span class="o">=</span> <span class="n">UIWindowLevelAlert</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">window_</span> <span class="nl">addGestureRecognizer</span><span class="p">:[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">windowClick</span><span class="p">)]];</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<ul>
<li>把全部scrollView寻找出来，在判断是否是当前界面显示的，把scrollView滑到顶部</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//寻找全部的scrollView</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">searchScrollViewInView:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">superView</span><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="bp">UIScrollView</span> <span class="o">*</span><span class="n">scroView</span> <span class="k">in</span> <span class="n">superView</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([</span><span class="n">scroView</span> <span class="nl">isKindOfClass</span><span class="p">:[</span><span class="bp">UIScrollView</span> <span class="k">class</span><span class="p">]]</span><span class="o">&amp;&amp;</span><span class="n">scroView</span><span class="p">.</span><span class="n">isShowingOnCurrentWindow</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="bp">CGPoint</span> <span class="n">offSet</span> <span class="o">=</span> <span class="n">scroView</span><span class="p">.</span><span class="n">contentOffset</span><span class="p">;</span>
</span><span class='line'>            <span class="n">offSet</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">scroView</span><span class="p">.</span><span class="n">contentInset</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
</span><span class='line'>            <span class="p">[</span><span class="n">scroView</span> <span class="nl">setContentOffset</span><span class="p">:</span><span class="n">offSet</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">searchScrollViewInView</span><span class="p">:</span><span class="n">scroView</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//判断是否是当前屏幕正在显示的view</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isShowingOnCurrentWindow</span><span class="p">{</span>
</span><span class='line'><span class="c1">//   一主窗口左上角为坐标原点，计算self的矩形框</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">newFrame</span> <span class="o">=</span> <span class="p">[</span><span class="n">ETKeyWindow</span> <span class="nl">convertRect</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">frame</span> <span class="nl">fromView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">superview</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">winBounds</span> <span class="o">=</span> <span class="n">ETKeyWindow</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'><span class="c1">//    主窗口的bouns 和self的矩形框 是否有重叠</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">insterects</span> <span class="o">=</span>  <span class="n">CGRectIntersectsRect</span><span class="p">(</span><span class="n">newFrame</span><span class="p">,</span> <span class="n">winBounds</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="nb">self</span><span class="p">.</span><span class="n">isHidden</span> <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="p">.</span><span class="n">window</span><span class="o">==</span><span class="n">ETKeyWindow</span> <span class="o">&amp;&amp;</span> <span class="n">insterects</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>至于怎么双击当前底部菜单栏然后刷新页面，可以把菜单栏点击的时候记录当次点击的菜单栏，下一次在点击的时候判断是否是上一次的菜单栏，然后调用开始刷新的方法。(这个需求实现与上面方法不同的是，这个不需要获取scroolView)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    在通知中心注册通知</span>
</span><span class='line'>    <span class="p">[</span><span class="n">ETDefaultNotificationCenter</span> <span class="nl">postNotificationName</span><span class="p">:</span><span class="n">ETTabBarDidSelectNotification</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//       接收通知</span>
</span><span class='line'><span class="p">[</span><span class="n">ETDefaultNotificationCenter</span> <span class="nl">addObserver</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">tabBarClick</span><span class="p">)</span> <span class="nl">name</span><span class="p">:</span><span class="n">ETTabBarDidSelectNotification</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//       开始滚</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">lasetSelectIndex</span> <span class="o">==</span> <span class="nb">self</span><span class="p">.</span><span class="n">tabBarController</span><span class="p">.</span><span class="n">selectedIndex</span><span class="o">&amp;&amp;</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">isShowingOnCurrentWindow</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">header</span> <span class="n">beginRefreshing</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">lasetSelectIndex</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">tabBarController</span><span class="p">.</span><span class="n">selectedIndex</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>需求场景</h4>

<ul>
<li>(场景1.0)有这么一个需求，要在一个view的子控件modal一个带有导航栏的控制器，

<ul>
<li>解决方案：获取keyWindow的根控制器，再modal一个带有控制器的导航控制器即可</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">UIView</span> <span class="nl">animateWithDuration</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">animations</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="p">[[</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">keyWindow</span><span class="p">.</span><span class="n">rootViewController</span> <span class="nl">presentViewController</span><span class="p">:[[</span><span class="n">ETNavContioller</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRootViewController</span><span class="p">:[[</span><span class="n">ETPublishController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]]</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span> <span class="nl">completion</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>(场景1.1)如何在一个已经modal出来的导航控制器的的跟控制器里面的一个子控制器里面push一个控制器。

<ul>
<li>知识拓展：一旦A控制器modal出B控制器，那么A的preferenceControlled就会引用着B控制器,所以可以这样做，获取当前的导航控制器，然后再获取他的presentedViewController</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//    获取keyWindow的keyWindow</span>
</span><span class='line'>    <span class="bp">UIViewController</span> <span class="o">*</span><span class="n">keyRootVC</span> <span class="o">=</span> <span class="n">ETKeyWindow</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">;</span>
</span><span class='line'><span class="c1">//    获取keyWindowmodel出的导航栏控制器</span>
</span><span class='line'>    <span class="n">ETNavContioller</span> <span class="o">*</span><span class="n">nav</span> <span class="o">=</span> <span class="p">(</span><span class="n">ETNavContioller</span> <span class="o">*</span><span class="p">)</span><span class="n">keyRootVC</span><span class="p">.</span><span class="n">presentedViewController</span><span class="p">;</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>    <span class="n">ETTagEditController</span> <span class="o">*</span><span class="n">tagEditVC</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ETTagEditController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">nav</span> <span class="nl">pushViewController</span><span class="p">:</span><span class="n">tagEditVC</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>(场景2)如果返回的图太大，我们就要定住他的宽度，然后再根据比例把它的高计算出来，但是如果计算出来的高度也太高了，我们就要显示他的顶部的一部分，但是如果把一张长图，在一个cell里面显示指定位置的一部分，这时就需要画图技术。

<ul>
<li>把截图想象成一个窗口，窗口后面是我们想要看到的一幅画，我们想看到画的哪里，只能挪动窗口后面的画，                <code>UIGraphicsBeginImageContextWithOptions(_data.pictureF.size, YES, 0.0);</code>这句代码就是设置我们的窗口大小以及其他属性，                <code>[currentImage drawInRect:CGRectMake(0, 0, _data.pictureF.size.width,picH)];</code>而这句话是设置图片哪个位置显示在窗口上面。</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">currentImage</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">contentPic</span><span class="p">.</span><span class="n">image</span><span class="p">;</span>
</span><span class='line'> <span class="n">CGFloat</span> <span class="n">picH</span> <span class="o">=</span> <span class="n">_data</span><span class="p">.</span><span class="n">pictureF</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">_data</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">_data</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>                <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">_data</span><span class="p">.</span><span class="n">pictureF</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">YES</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span><span class='line'>                <span class="p">[</span><span class="n">currentImage</span> <span class="nl">drawInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_data</span><span class="p">.</span><span class="n">pictureF</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="n">picH</span><span class="p">)];</span>
</span><span class='line'>                <span class="n">currentImage</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>                <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">contentPic</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">currentImage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>小结：UIGraphicsBeginImageContextWithOptions(决定显示大小)，drawInRect:CGRectMake决定显示图片的一部分在窗口上。</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[百思不得姐-项目总结(一)]]></title>
    <link href="http://etund.github.com/blog/2015/02/20/bai-si-bu-de-jie-xiang-mu-zong-jie-%5B%3F%5D/"/>
    <updated>2015-02-20T18:54:55+08:00</updated>
    <id>http://etund.github.com/blog/2015/02/20/bai-si-bu-de-jie-xiang-mu-zong-jie-[?]</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<ul>
<li>这个项目是一个段子类的项目，百思不得姐，一个段子软件，具体情况自己下载来玩吧。</li>
</ul>


<!-- more -->


<h3>小技巧(一)</h3>

<h4>自定义导航栏注意的地方</h4>

<ul>
<li>在iOS7之后，当我们的收在左边最边边开始往右划的时候会实现返回功能，但是当我们自定义导航栏的返回按钮的时候这个功能就会失去，这时候我们只需要可以把这样设置就好了<code>self.interactivePopGestureRecognizer.delegate = nil;</code></li>
<li>但是这样会出现在我们返回到第一个控制器的时候，在往右滑，在点击跳转，跳转不过去，解决方案

<ul>
<li>在pushViewController:animated:方法的时候设置代理的等于当前控制器是否是根控制器。</li>
<li>然后成为导航控制器的代理，然后实现其代理方法navigationController:didShowViewController:animated:在里面设置代理等于当前控制器是否是根控制器</li>
<li>核心代码</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mi">1</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">popDelegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'>   <span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="mi">3</span>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">navigationController</span><span class="p">:(</span><span class="bp">UINavigationController</span> <span class="o">*</span><span class="p">)</span><span class="n">navigationController</span> <span class="nl">didShowViewController</span><span class="p">:(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">animated</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">viewController</span> <span class="o">==</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">viewControllers</span> <span class="n">firstObject</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">popDelegate</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这时我们可以有更高的要求，例如我们想自定义手势，因为系统自带的手势只能从左边边界开始划，但是自定义手势的时候我们也要跟上面一样判断什么时候响应手势的触发</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">在</span><span class="n">viewDidLoad</span><span class="err">里面</span>
</span><span class='line'><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">pan</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handleNavigationTransition</span><span class="p">:)];</span>
</span><span class='line'>    <span class="n">pan</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">pan</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="err">在代理方法里面</span>
</span><span class='line'><span class="cp">#pragma UIGestureRecognizerDelegate</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nl">gestureRecognizerShouldBegin</span><span class="p">:(</span><span class="bp">UIGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="n">gestureRecognizer</span><span class="p">{</span>
</span><span class='line'><span class="c1">//    当当前控制器不是根控制器的时候可以接收</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">topViewController</span> <span class="o">!=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">viewControllers</span> <span class="n">firstObject</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>时间比较</h4>

<ul>
<li>时间处理

<ul>
<li>目标：刚刚 一小时内 几时几分  昨天几时几分 几月几号几时几分 几年几月几号几时几分</li>
<li>概要：是否是今年 是否是昨天 是否是今天 是否是一个小时外 是否是一分钟外</li>
<li>优先级判断

<ul>
<li>判断是否是今年 ：年份一样？今年：去年</li>
<li>判断是否是昨天：年份一样，月份一样或相差一个月，天数相差一天或一个月</li>
<li>判断是否是今天：年份一样，月份一样，日期一样</li>
<li>判断是否是一个小时内？年份一样，月份一样，日期一样，时一样</li>
<li>判断是否是一分钟内：年份一样，月份一样，日期一样，时一样，分钟一样</li>
</ul>
</li>
<li>如何判断时间一样？

<ul>
<li>利用NSCalendar的方法来比较</li>
</ul>
</li>
<li>列几个代码</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//判断是否是今天</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isTody</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dfm</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">dfm</span><span class="p">.</span><span class="n">dateFormat</span> <span class="o">=</span> <span class="s">@&quot;yyyy-MM-dd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">selfDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfm</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">nowDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfm</span> <span class="nl">stringFromDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">selfDate</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">nowDate</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//判断是否是今年</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isThisYear</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSCalendar</span> <span class="n">currentCalendar</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSInteger</span> <span class="n">nowYear</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">component</span><span class="p">:</span><span class="n">NSCalendarUnitYear</span> <span class="nl">fromDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'>    <span class="bp">NSInteger</span> <span class="n">selfYear</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">component</span><span class="p">:</span><span class="n">NSCalendarUnitYear</span> <span class="nl">fromDate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">nowYear</span> <span class="o">==</span> <span class="n">selfYear</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//是否是昨天</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isYesterday</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dfm</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">dfm</span><span class="p">.</span><span class="n">dateFormat</span> <span class="o">=</span> <span class="s">@&quot;yyyy-MM-dd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">selfDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfm</span> <span class="nl">dateFromString</span><span class="p">:[</span><span class="n">dfm</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="nb">self</span><span class="p">]];</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">nowDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfm</span> <span class="nl">dateFromString</span><span class="p">:[</span><span class="n">dfm</span> <span class="nl">stringFromDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSCalendar</span> <span class="n">currentCalendar</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSDateComponents</span> <span class="o">*</span><span class="n">contents</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">components</span><span class="p">:</span><span class="n">NSCalendarUnitYear</span><span class="o">|</span><span class="n">NSCalendarUnitMonth</span><span class="o">|</span><span class="n">NSCalendarUnitDay</span> <span class="nl">fromDate</span><span class="p">:</span><span class="n">selfDate</span> <span class="nl">toDate</span><span class="p">:</span><span class="n">nowDate</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">contents</span><span class="p">.</span><span class="n">year</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">contents</span><span class="p">.</span><span class="n">month</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">contents</span><span class="p">.</span><span class="n">day</span><span class="o">==</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>知道是否是今年，或者今天等等后，还要返回具体要显示什么内容</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//获取时间差</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSDateComponents</span> <span class="o">*</span><span class="p">)</span><span class="nf">getShortDateComponents</span><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dfm</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">dfm</span><span class="p">.</span><span class="n">dateFormat</span> <span class="o">=</span> <span class="s">@&quot;yyyy-MM-dd HH:mm&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dfm</span><span class="p">.</span><span class="n">timeZone</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSTimeZone</span> <span class="nl">timeZoneWithName</span><span class="p">:</span><span class="s">@&quot;Etc/GMT+8&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">nowDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfm</span> <span class="nl">dateFromString</span><span class="p">:[</span><span class="n">dfm</span> <span class="nl">stringFromDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]]];</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">selfDate</span>  <span class="o">=</span> <span class="p">[</span><span class="n">dfm</span> <span class="nl">dateFromString</span><span class="p">:[</span><span class="n">dfm</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="nb">self</span><span class="p">]];</span>
</span><span class='line'>    <span class="bp">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSCalendar</span> <span class="n">currentCalendar</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">components</span><span class="p">:</span><span class="n">NSCalendarUnitYear</span><span class="o">|</span><span class="n">NSCalendarUnitMonth</span><span class="o">|</span><span class="n">NSCalendarUnitDay</span><span class="o">|</span><span class="n">NSCalendarUnitHour</span><span class="o">|</span><span class="n">NSCalendarUnitMinute</span> <span class="nl">fromDate</span><span class="p">:</span><span class="n">selfDate</span> <span class="nl">toDate</span><span class="p">:</span><span class="n">nowDate</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;未完待续</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文件下载(二)]]></title>
    <link href="http://etund.github.com/blog/2014/11/07/wen-jian-xia-zai-er/"/>
    <updated>2014-11-07T17:32:40+08:00</updated>
    <id>http://etund.github.com/blog/2014/11/07/wen-jian-xia-zai-er</id>
    <content type="html"><![CDATA[<h3>NSURLSession多文件断点下载</h3>

<ul>
<li>上次已经完成了单文件断点下载，现在就开始实现多文件断点下载，接下来要实现单文件下载。</li>
<li>为了方便，把之前在文件控制器文件中的下载文件抽取出来，封装成一个专门用来下载的类，假设我们调用方法，只需要存进一个url，这个工具类就会默认的把我们的下载好的文件放进cache文件里面，并且不断返回进度，于是乎我们假设封装好的方法是这样的。</li>
</ul>


<!-- more -->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *remoteURL = @"http://120.25.226.186:32812/resources/videos/minion_01.mp4";
</span><span class='line'>    [ETURLDownLoadSession downloadWithURL:remoteURL complete:^(CGFloat downLoadScale) {
</span><span class='line'>        NSLog(@"-------------%f",downLoadScale);
</span><span class='line'>    }];</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>亦即是说我们只需要调用ETURLDownLoadSession的类方法就可以实现多文件断点下载了，接下来我们就要实现这个类方法了。</p></li>
<li><p>我们在封装类里面是通过类方法类调用实例方法的，就像这样。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark -  初始化方法
</span><span class='line'>+ (void)downloadWithURL:(NSString *)remoteURL complete:(void (^)(CGFloat downLoadScale))complete{    
</span><span class='line'>    ETURLDownLoadSession *downLoad = [[ETURLDownLoadSession alloc] init];
</span><span class='line'>    [downLoad downloadWithURL:remoteURL complete:complete];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)downloadWithURL:(NSString *)remoteURL complete:(void (^)(CGFloat downLoadScale))complete{
</span><span class='line'>    self.remoteURL = remoteURL;
</span><span class='line'>    [self downLoad];
</span><span class='line'>    if (complete) {
</span><span class='line'>        complete(self.downLoadScale)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>downLoadSacle是在NSURLSession代理方法中接受数据的方法里面已经接受的数据的比例。但是这里发现，只是在初始方法里面执行一次，那么我们在外头想时刻知道下载比例的变化，要怎么做呢？分析一下。</p>

<ul>
<li>首先，要时刻执行block，而block的下载比例是时刻变化的，这是使用KVO再适合不过了。</li>
<li>然后block就不是在初始化方法里面执行了，要在监听值变化的方法里面执行，于是乎要把block前值为全局变量，首先的定义一个跟传进来block一样的block类型。</li>
</ul>


<pre><code class="``">  //定义block类型
  typedef void (^scaleChangeBlock)(CGFloat downloadScale);
  //定义block变量
  @property (nonatomic, strong) scaleChangeBlock scaleBlock;
</code></pre></li>
<li><p>于是乎在- (void)downloadWithURL:(NSString *)remoteURL complete:(void (^)(CGFloat downLoadScale))complete;方法里面添加Observer来监听KVO的变化。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//    添加KVO
</span><span class='line'>    [self addObserver:self forKeyPath:@"downLoadScale" options:NSKeyValueObservingOptionNew context:nil];
</span><span class='line'>    self.remoteURL = remoteURL;
</span><span class='line'>    [self downLoad];
</span><span class='line'>    if (complete) {
</span><span class='line'>        self.scaleBlock = complete;
</span><span class='line'>    }
</span><span class='line'>//在监听值变化的方法里面调用block
</span><span class='line'>    //开始监听
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{
</span><span class='line'>    self.scaleBlock(self.downLoadScale);
</span><span class='line'>}
</span><span class='line'>//最后要记得在要移除值KVO
</span><span class='line'>#pragma mark - 移除KVO
</span><span class='line'>- (void)dealloc{
</span><span class='line'>    [self removeObserver:self forKeyPath:@"downLoadScale" context:nil];
</span><span class='line'>    NSLog(@"----dealoc--");
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文件断点下载(一)]]></title>
    <link href="http://etund.github.com/blog/2014/11/05/wen-jian-xia-zai-%5B%3F%5D/"/>
    <updated>2014-11-05T17:29:20+08:00</updated>
    <id>http://etund.github.com/blog/2014/11/05/wen-jian-xia-zai-[?]</id>
    <content type="html"><![CDATA[<h2>NSURLSession单文件断点下载</h2>

<ul>
<li>介绍

<ul>
<li>NSURLSession是iOS7推出的，旨在提供比NSURLConenection方便的网络需求实现方式，并取缔他，也的确做到了，在iOS9NSURLConenection已经过期了，这里介绍利用NSURLSession的代理实现断点下载。</li>
</ul>
</li>
<li>思路

<ul>
<li>初始化NSURLSession同时设置代理</li>
<li>初始化文件IO流</li>
<li>实现初级下载</li>
<li>在上次下载的地方重新下载</li>
</ul>


<p>  <code>额外需求</code></p>

<ul>
<li>实现当用户下载完成的时候下次下载不会再发请求</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li>在Session懒加载的设置代理</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc] init]];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>实现代理方法，在收到用户点击的时候在task的懒加载的时候初始化task，并且开启任务</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://120.25.226.186:32812/resources/videos/minion_05.mp4"]];
</span><span class='line'>    _task = [self.session dataTaskWithRequest:request];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>分别在接接收到数据，接收到响应，数据传输完成中座操作</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//接收到响应
</span><span class='line'>- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask
</span><span class='line'>                                 didReceiveResponse:(NSURLResponse *)response
</span><span class='line'>                                  completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler;
</span><span class='line'>                                  
</span><span class='line'>//接收到数据
</span><span class='line'>- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask- 
</span><span class='line'>                                     didReceiveData:(NSData *)data;
</span><span class='line'>//数据传输完成
</span><span class='line'>- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session NS_AVAILABLE_IOS(7_0);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在接收到响应的时候开启数据IO流，并且设置可以接受数据(NSURLSession要默认不会接受数据，要手动设置接受数据)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//    开启数据io流
</span><span class='line'>    [self.outStream open];
</span><span class='line'>//    设置接受数据
</span><span class='line'>    completionHandler(NSURLSessionResponseAllow);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在接收到数据的时候用IO流把数据写入文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//    获取本地文件的大小
</span><span class='line'>    [self.outStream write:data.bytes maxLength:data.length];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在数据接收完毕的时候关闭流</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self.outStream close];
</span><span class='line'>self.outStream = nil;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>现在，是可以实现数据传入，并且按暂停可以暂停，按重新开始也可以开始了。</li>
<li>然而，当有电话打过来的时候或者用户异常退出的时候用户再进入，下载的时候，任务又重新开始了。</li>
<li>这是我们可以这样实现，拿到当前已经下载文件的大小，而后在HTTP协议中告诉服务器，我们从当前文件大小后面的字节数开始下载，于是乎，在定义request的时候设置HTTP请求头的属性。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    NSString *range = [NSString stringWithFormat:@"bytes=%zd-",[[[NSFileManager defaultManager] attributesOfItemAtPath:ETFileSavePath error:nil][NSFileSize] integerValue]];
</span><span class='line'>    [request setValue:range forHTTPHeaderField:@"Range"];</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>现在是可以做到下载文件中用户直接退出或者来电话的时候实现断点下载。</p></li>
<li><p>现在可以完善细节</p>

<ul>
<li>看一下我们的额外需求，实现当用户下载完成的时候下次下载不会再发请求，按照我们原来的代码，虽然说可以实现当下载完成的时候不会再继续下载，但是这是因为我们每次都会获取当前文件的大小，然后再跟服务器说我们从最后一个字节开始，然而肯定没有字节下载。</li>
<li>额，我们想不发送请求直接可以想判断当前是否已经下载完成，于是乎可以这样，在创建发送请求的时候获取总文件大小，每次创建Task的时候判断下载的文件和总文件大小是否一致并且不为0再来判断是否要创建Task</li>
</ul>


<pre><code class="`">//在懒加载Task的时候
//        获取上次存储的文件长度
//        这样做的需求是为了不浪费用户的流量
      NSInteger lastTimeLength = [[NSDictionary dictionaryWithContentsOfFile:ETFileLeggthSavePath][ETSavedFieldName]
                                  integerValue];
      if (lastTimeLength!=0 &amp;&amp; lastTimeLength==ETSavedFileSize) {
//            NSLog(@"==========%f",(1.0 * ETSavedFileSize/lastTimeLength));
          NSLog(@"已经下载过了");
          return nil;
      }
//在接收到响应的代理方法的时候加上
    //    记录下载数据流
  self.dataLength = [response.allHeaderFields[@"Content-Length"] integerValue] + ETSavedFileSize;

  //    存储本次文件的长度
  //    记录下载数据流
  self.dataLength = [response.allHeaderFields[@"Content-Length"] integerValue] + ETSavedFileSize;


  //    记录下载数据流
  self.dataLength = [response.allHeaderFields[@"Content-Length"] integerValue] + ETSavedFileSize;
  //    存储本次文件的长度
  [@{ETSavedFieldName:@(self.dataLength)} writeToFile:ETFileLeggthSavePath atomically:YES];
</code></pre></li>
<li>额，然后这样是可以在每次启动不发流量的前提下检查是否已经下载完成，但是想到，文件大小应该是一开始到最后都是一样的，那么我们为什么要每次存储呢？我们只需要存储一次就好了。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> //    先取出存储的文件长度是否已经存在
</span><span class='line'>    NSInteger lastTimeLength = [[NSDictionary dictionaryWithContentsOfFile:ETFileLeggthSavePath][ETSavedFieldName] integerValue];
</span><span class='line'>    if (!lastTimeLength){
</span><span class='line'>        //    存储本次文件的长度
</span><span class='line'>        [@{ETSavedFieldName:@(self.dataLength)} writeToFile:ETFileLeggthSavePath atomically:YES];
</span><span class='line'>    } </span></code></pre></td></tr></table></div></figure>


<ul>
<li>至此，我们实现了一些需求

<ul>
<li>可以实现文件在线断点下载</li>
<li>可以在我们不正常退出正在下载任务的时候从新开始下载。</li>
<li>可以实现在用户下载完的时候不发请求检查任务是否已经下载完成。</li>
</ul>
</li>
<li>单文件下载基本上是可以了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅拷贝与深拷贝]]></title>
    <link href="http://etund.github.com/blog/2014/08/22/qian-kao-bei-yu-shen-kao-bei/"/>
    <updated>2014-08-22T14:15:33+08:00</updated>
    <id>http://etund.github.com/blog/2014/08/22/qian-kao-bei-yu-shen-kao-bei</id>
    <content type="html"><![CDATA[<h4>深拷贝与浅拷贝</h4>

<ul>
<li>浅拷贝是指针拷贝，深拷贝是内容拷贝</li>
<li>产生新对象的时深拷贝，不产生新对象的时浅拷贝</li>
<li><p>浅拷贝只是对对象的简单拷贝，让几个对象公用一片内存，当内存销毁的时候，只想这片内存的额几个指针需要重新定义才可以使用，要不然会变成野指针。</p></li>
<li><p>NString与copy(不产生新对象，浅拷贝，指针拷贝)</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;00000000000&quot;</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">str_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">str</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%p---------%p&quot;</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="n">str_0</span><span class="p">);</span>
</span><span class='line'><span class="cm">/**输出结果</span>
</span><span class='line'><span class="cm">2015-08-22 12:42:24.992 Text[1143:32063] 0x10128c7d0---------0x10128c7d0</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<!-- more -->


<ul>
<li>NString与mutableCopy(产生新对象，深拷贝，内容拷贝)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;00000000000&quot;</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">str_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">str</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%p---------%p&quot;</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="n">str_0</span><span class="p">);</span>
</span><span class='line'><span class="cm">/**输出结果</span>
</span><span class='line'><span class="cm">2015-08-22 12:44:39.582 Text[1183:33573] 0x1042cb7d0---------0x7f9bf401a910</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSMutableString与copy(产生新对象，深拷贝，内容拷贝)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString</span><span class="p">:</span><span class="s">@&quot;-----------&quot;</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">str</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%p---------%p&quot;</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="n">str_0</span><span class="p">);</span>
</span><span class='line'><span class="cm">/**输出结果</span>
</span><span class='line'><span class="cm">2015-08-22 12:47:06.886 Text[1219:34965] 0x7fa5e26107d0---------0x7fa5e260fc00</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSMutableString与copy(产生新对象，深拷贝，内容拷贝)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString</span><span class="p">:</span><span class="s">@&quot;-----------&quot;</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">str</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%p---------%p&quot;</span><span class="p">,</span><span class="n">str</span><span class="p">,</span><span class="n">str_0</span><span class="p">);</span>
</span><span class='line'><span class="cm">/**输出结果</span>
</span><span class='line'><span class="cm">2015-08-22 12:48:26.251 Text[1247:36136] 0x7f8450725d40---------0x7f8450738150</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>小结：

<ul>
<li>NS<em> 调用copy方法是浅拷贝，调用mutableCopy方法是深拷贝，NSMutable</em> 调用mutableCopy和copy是深拷贝。</li>
<li>浅拷贝，在ARC中，由于自动管理内存，使用retain关键字进行引用计数，就是一种更加保险的浅拷贝，它既让几个指针共用同一片内存空间，又可以在release由于计数的存在，不会轻易的销毁内存，达到更加建档使用的目的</li>
<li>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存在的值是相同的，但内存地址不一样，两个对象也互不影响，互补干涉。</li>
</ul>
</li>
</ul>


<p><img src="http://etund.github.com/images/blog/qiancopyyushenkaobei/Snip20150822_2.png" alt="" /></p>

<h4>拷贝构造</h4>

<ul>
<li>在ios中不不是所有的对象原始就支持copy和mutableCopy，即使你可以调用这个方法且编译通过，但是在运行的时候会提示找不到方法copywithzone 或者 mutableCopyWithZone。所以如果其他类也想实现深拷贝或者浅拷贝的时候，要遵循NSMutableCopying或者NSCopying协议并且实现copyWithZone或者mutableCopyWithZone方法来实现深拷贝或浅拷贝。</li>
<li>举个栗子

<ul>
<li>没有实现copying的时候对AClass的实例进行copy,编译通过,但是运行报错
<img src="http://etund.github.com/images/blog/qiancopyyushenkaobei/Snip20150822_1.png" alt="" /></li>
<li>接下来我们来继承NSCopying协议并且实现对应的方法</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span><span class="p">{</span>
</span><span class='line'>    <span class="n">AClass</span> <span class="o">*</span><span class="n">aclass</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="nl">allocWithZone</span><span class="p">:</span><span class="n">zone</span><span class="p">];</span>
</span><span class='line'>    <span class="n">aclass</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">_name</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>    <span class="n">aclass</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">_age</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">aclass</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>之后在运行之前的代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">AClass</span> <span class="o">*</span><span class="n">aclass</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">aclass</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;00000000&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">aclass</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">AClass</span> <span class="o">*</span><span class="n">aclass_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">aclass</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@--------------%@&quot;</span><span class="p">,</span><span class="n">aclass</span><span class="p">,</span><span class="n">aclass_0</span><span class="p">);</span>
</span><span class='line'><span class="cm">/*输出结果</span>
</span><span class='line'><span class="cm">2015-08-22 14:07:11.509 Text[4180:74165] &lt;AClass: 0x7f91932298c0&gt;--------------&lt;AClass: 0x7f9193229770&gt;</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>小结：至于NSCopying同理。</li>
</ul>


<h4>参考文章</h4>

<ul>
<li><a href="http://www.cocoachina.com/ios/20141113/10213.html">Objective-C中的浅拷贝和深拷贝</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C_Runtime(二)]]></title>
    <link href="http://etund.github.com/blog/2014/07/28/objective-c-runtime-er/"/>
    <updated>2014-07-28T19:43:52+08:00</updated>
    <id>http://etund.github.com/blog/2014/07/28/objective-c-runtime-er</id>
    <content type="html"><![CDATA[<p><img src="http://etund.github.com/images/blog/Objective-c-Runtime/1436240778601754.jpg" alt="" /></p>

<h3>动态方法解析</h3>

<h4>动态方法解析</h4>

<ul>
<li>这里描述怎样动态提供一个方法的实现</li>
<li>有时候需要动态的提供一个方法的实现，例如OC中属性Property</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">￼￼￼￼</span><span class="k">@dynamic</span> <span class="n">propertyName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>表示编译器须动态的生成该属性对应的方法，<code>注意：￼￼￼￼@dynamic与@property一样都可以自动生成setter和getter方法，知识@property是编译阶段生成的，而@dynamic是手工生成或者运行时自动生成。</code></li>
<li>此外，还可以通过实现resolveInstanceMethod;和resolveeClassMethod；来动态地实现给定选标的对象方法或者类方法。</li>
<li>OC方法可以认为是至少两个参数的self和_cmd的C函数。你可以通过class_andMethod方法讲一个函数加入到类的方法中。例如，有如下函数：</li>
</ul>


<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">dynamicMethodIMP</span><span class="p">(</span><span class="kt">id</span> <span class="n">seld</span><span class="p">,</span><span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">//DOSomething</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>你可以通过resolveInstanceMethod:讲它作为resolveThisMethodDynamically的实现</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSEL</span><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">aSEL</span> <span class="o">==</span> <span class="k">@selector</span><span class="p">(</span><span class="n">resolveThisMethodDynamically</span><span class="p">)){</span>
</span><span class='line'>      <span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span><span class="n">aSEL</span><span class="p">,(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">dynamicMethodIMP</span><span class="p">,</span><span class="s">&quot;v@&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">resolveInstanceMethod</span><span class="p">:</span><span class="n">aSEL</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这是你可能会想到如果我消息已经发送出去了，然后再添加方法那不是没用，所以文档里面也锁了，消息转发和动态方法解析是互补相干的，在进入消息转发机制之前，respondsToSelector:和instancesRespondToSelector:会被首先调用。你可以在两个方法中为传进来的选标提供一个IMP.如果你实现了resolveInstanceMethod：方法但是仍然希望正常的消息转发机制进行，你只需要返回NO就可以了。</li>
</ul>


<h4>动态加载</h4>

<ul>
<li>动态加载其实很简单，例如我们在设置中要查看我们的手机存储空间，那么就是在我们想要看得时候，它采取加载，而，官方给出的解释比较拗口，即使翻译过来了还是比较生涩：Objective-C 程序可以在运行时链接和载入新的类和范畴类。新载入的类和在程序启动时载入的类并没有区别。意思就是说要用到时在加载，其实抛开这个局限来说，很多地方都用到这种动态加载的思想，可能就是叫法不同，例如，我们在iOS中经常用到的懒加载，以及控制器的view的懒加载，再如，Java中得Hibernate中的数据库load方法的懒加载，用到时再加载到内存中。这种思想在一定程度上节省了资源。</li>
<li>在回到OC，尽管已经有RunTime系统的函数动态加载Mach-O文件中的Objective-C模块(objc_loadModules,在objc/objc-load.h中定义),但是Cocoa的NSBundle类为动态加载提供了一个更为方便的借口哦——一个面向对象，已知相关服务集成的接口。</li>
</ul>


<h3>消息转发</h3>

<h4>消息转发</h4>

<ul>
<li>如果一个对象受到一条无法处理的消息，运行时系统会在抛出错误前，给该对象发送一条是forwardInvocation:消息，该消息的唯一参数是个NSInvocation类型的对象，该对象封装了原始的消息和消息的参数。</li>
<li>你可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以一其他的某种方式来避免错误的抛出。如forwardInvocation:的名字所示，它通常用来将消息转发给其他的对象。</li>
<li>关于消息转发的作用,您可以考虑如下情景:假设,您需要设计一个能够响应 negotiate 消息的对象, 并且能够包括其它类型的对象对消息的响应。 通过在 negotiate 方法的实现中将 negotiate 消息 转发给其它的对象来很容易的达到这一目的。
<code>上面这段话的内容是只建一个类似于中介的类(这个类有实现negotiate方法)，然后把这个forward的消息转发给你想要转发的类</code></li>
<li>更进一步,假设您希望您的对象和另外一个类的对象对negotiate的消息的响应完全一致。一种可能的 方式就是让您的类继承其它类的方法实现。 然后,有时候这种方式不可行,因为您的类和其它类可能需要在不同的继承体系中响应 negotiate 消息。
<code>上面这句话只是对上上一句话换一种说法而已，意思就是说，如果你得对象和另外一个类对象对neGotiate的消息响应一致(也就是实现一致，响应的方式一致)，你就要继承能响应这个消息的类，但是这种工程是庞大的，因为你要在每个继承体系中响应这个消息</code></li>
<li>然而即使你不能通过继承来继承这个实现，你也可以自定义一个negotiate实现来响应这个消息,(当然这种方法对于很多类来说是不可取的，工作量太大了),而这个消息只是转发消息而已，就像一开始举得例子一样</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="nf">negotiate</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="p">[</span><span class="n">someOtherObject</span> <span class="nl">respondsTo</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">negotiate</span><span class="p">)]</span> <span class="p">)</span>
</span><span class='line'><span class="k">return</span> <span class="p">[</span><span class="n">someOtherObject</span> <span class="n">negotiate</span><span class="p">];</span>
</span><span class='line'><span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>如上所说，这种方法在很多方法的时候是不可取的，此外，当你写完代码的时候，你可以处理的消息就已经去顶的，意思就是不能处理位置的消息，而且你得类以及方法表都是确定的，但是根据上面动态方法解析可以知道，有些方法和类是动态加载的。</p></li>
<li><p>forwardInvocation:消息给这个问题提供了一个更特别的,动态的解决方案:当一个对象由于没有 相应的方法实现而无法响应某消息时,运行时系统将通过 forwardInvocation:消息通知该对象。每 个对象都从 NSObject 类中继承了 forwardInvocation:方法。然而,NSObject 中的方法实现 只是简单地调用了 doesNotRecognizeSelector:,所以就出现了我们经常遇到的问题,unreconizeSelector send to &hellip;. 就是找不到方法的意思</p></li>
<li>此外，我们也可以通过自己实现forwarfInvocation方法来实现我们的消息转发，但是正如一开始说的，我们发送消息，必须包含方法调用者，消息以及其包含的参数</li>
<li>至于转发的具体实现，我们可以通过invokeWithTarget:方法来转发</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation:</span><span class="p">(</span><span class="bp">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anInvocation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">someOtherObject</span> <span class="nl">respondsToSelector</span><span class="p">:</span>
</span><span class='line'><span class="p">[</span><span class="n">anInvocation</span> <span class="n">selector</span><span class="p">]])</span>
</span><span class='line'><span class="p">[</span><span class="n">anInvocation</span> <span class="nl">invokeWithTarget</span><span class="p">:</span><span class="n">someOtherObject</span><span class="p">];</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="p">[</span><span class="nb">super</span> <span class="nl">forwardInvocation</span><span class="p">:</span><span class="n">anInvocation</span><span class="p">];</span>
</span><span class='line'><span class="err">￼</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>转发消息后返回值将返回给原来的额消息发送者，所以你可以返回任何类型的返回值</li>
<li>forwardInvocation:就像一个不能识别的消息分发中心，你可以将这些消息分发给不同的对象，也可以分发给同一个对象，也可以不做任何事，就是吃掉，因此没有响应也没有错误。forwardInvocation:也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。
<code>值得注意的是，forwardInvocation:方法只有在消息对象无法啊正常响应的时候调用，因此如果你想调用某个对象的某个方法，那么某个对象的一定不能有则个方法，否者forwardInvocation:将不可能被调用</code></li>
</ul>


<h4>消息转发和多重继承</h4>

<ul>
<li>当我看到这个的时候要我接受我是拒绝的，这按照常规真的很难理解，但是仔细想想，这并不是真正的多重继承，只是模拟多重继承而已，当然这个前提是你已经理解消息转发，也就是上面我说的。</li>
</ul>


<p><img src="http://etund.github.com/images/blog/Objective-c-Runtime/forwarding.gif" alt="消息转发" /></p>

<ul>
<li>如图所示，Warrior里面把调用negotiate方法的消息转发给Diplomat,也可以这样说，Warrior间接调用了Diplmat，而Warrior有自己的继承体系，而Diplomat也有自己的继承体系，所以这样就可以看做是Warrior模拟出了多重继承的效果</li>
<li>消息转发提供了多重继承的很多特性，然而多重继承是讲不通的行为封装到单个对象中，有可能导致很庞大，复杂的对象，而且有些不必要的方法也继承过来了，没必要的庞大。而消息转发是将问题分解到更小的对象中，但是又以一种对消息发送对象来说完全透明的方式将这些对象联系起来。</li>
</ul>


<h4>消息代理对象</h4>

<ul>
<li>消息转发不仅和继承很象,它也使得以一个轻量级的对象(消息代理对象)代表更多的对象进行消息处理成为可能。</li>
<li>远程消息的代理类就是这样一个代理对象，代理类负责将消息转发给远程消息接收对象的管理细节，也就是说，保证消息参数的传输，他没有进一步复制远程对象，只是把远程对象的映射到本地的地址，也就是说，显示接收你远程消息的对象并没有真正处理消息对象的方法，他只是将消息转发给真正处理的额类。</li>
<li>同时也存在其他类型的消息代理对象。例如，假设你有个对象需要操作大量数据&mdash;他需要从一个复杂的图片或者需要从磁盘上附一个文件上的内容，而创建一个这样的一个对象有很费时间费资源，这样就可能需要推迟他的创建时间&mdash;&mdash;-知道它真正需要是，或者系统资源空闲是再来加载这个方法。同时你有需要至少有一个预留的对象和其他对象和其他对象交互。<code>简而言之，也是懒加载，首先要知道的时我们利用forwardInvocation:来转发消息在真正执行到这一句之前，里面的代码是没有加载到内存，只有在执行过程中真正找不到方法才能加载里面的代理进内存</code></li>
<li>在这种情况下,你可以为该对象创建一个轻量的代理对象。该代理对象可以有一些自己的功能,例如响应数据查询消息,但是它主要的功能是代表某个对象,当时间到来时,将消息转发给被代表的对象。当代理对象的 forwardInvocation:方法收到需要转发给被代表的对象的消息时,代理对象会保证所代表的 对象已经存在,否则就创建它。所有发到被代表的对象的消息都要经过代理对象,对程序来说,代理对象 和被代表的对象是一样的。</li>
</ul>


<h4>消息转发和类继承</h4>

<ul>
<li>尽管消息转发很像继承，但他不是继承，例如在NSObject类中，方法respondsToSelector:和isKindOfClass:只会出现在继承链中，而不是消息转发链中。例如，如果向Warrior类的对象询问他能否响应negotiate消息。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="p">[</span><span class="n">aWarrior</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">negotiate</span><span class="p">)]</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>返回值是NO，尽管该对象能够接受和响应negotiate，但部分情况下，NO是正确的响应。但不是所有时候都是的，例如，如果你使用消息转发来创建一个代理，对象易扩展某个类的能力，这儿的消息转发必须和继承一样，尽可能地对用户透明，如果你希望你的代理对象看起来就像是继承自它代表的对象，一样，你需要重新实现respondsToSelector:和isKindOfClass:方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">]</span> <span class="p">)</span>
</span><span class='line'><span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="k">else</span> <span class="p">{</span>
</span><span class='line'><span class="cm">/* Here, test whether the aSelector message can *</span>
</span><span class='line'><span class="cm">* be forwarded to another object and whether that *</span>
</span><span class='line'><span class="cm">* object can respond to it. Return YES if it can. */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="err">￼</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>除了respondsToSelector:和isKindOfClass:外，instancesRespondToSelector:方法也必须重新实现。如果你是用的是协议类，需要重新实现的还有conformsToProtocol:方法。类似的，如果对象需要转发远程消息，择methodSignatureForSelector:方法必须能够返回实际响应消息的方法的描述，例如，如果对象需要将消息转发给他所代表的对象，你可能需要如下的methodSignatureForSelector:实现</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSMethodSignature</span><span class="o">*</span><span class="p">)</span><span class="nf">methodSignatureForSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="bp">NSMethodSignature</span><span class="o">*</span> <span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">methodSignatureForSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signature</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="n">surrogate</span> <span class="nl">methodSignatureForSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">signature</span><span class="p">;</span>
</span><span class='line'><span class="err">￼</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>您也可以将消息转发的部分放在一段私有的代码里,然后从 forwardInvocation:调用它。</code>
<code>注意: 消息转发是一个比较高级的技术,仅适用于没有其它更好的解决办法的情况。它并不是用来代替 继承的。如果您必须使用该技术,请确定您已经完全理解了转发消息的类和接收转发消息的类的行为。</code></p>

<h3>其他</h3>

<ul>
<li>除了上面提到的，运行时模块还包括<code>类型编码</code>和<code>属性声明</code>，在<code>属性声明</code>里面有我们经常用到的class_copyPropertyList和protocol_copyPropertyList用来运行时获取私有属性的。</li>
</ul>


<h3>总结</h3>

<ul>
<li>其实OC成为一门动态的语言，就是应为它的运行时，从其本，Objective-C语言将决定尽可能的从编译和连接时推迟到运行时，只要有可能Objective-C总是使用动态的方式来解决问题，所以运行时整个文档中可以看中OC的Runtime懒懒的感觉，就是因为动态为其提供灵活性。</li>
<li>Runtime我觉得<code>消息转发</code>这个模块比较重要，也比较难懂，只要理解了，整个文档看起来就不会太难了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C_Runtime(一)]]></title>
    <link href="http://etund.github.com/blog/2014/07/24/objective-c-runtime-%5B%3F%5D/"/>
    <updated>2014-07-24T01:16:29+08:00</updated>
    <id>http://etund.github.com/blog/2014/07/24/objective-c-runtime-[?]</id>
    <content type="html"><![CDATA[<p><img src="http://etund.github.com/images/blog/Objective-c-Runtime/1436240778601754.jpg" alt="" /></p>

<h3>前言</h3>

<ul>
<li>此博文仅仅用于本人的读书笔记，一切以官方的为准<a href="https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">官方文档</a></li>
<li>Objective-C语言将决定尽可能的从编译和连接时推迟到运行时，只要有可能Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这儿的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。</li>
</ul>


<!-- more -->


<h3>和Runtime系统的交互</h3>

<ul>
<li>Objective-C程序有三种途径各运行时系统交互

<ul>
<li>通过Objective-C源代码：意思就是你自己写代码发消息，然后在编译的时候，编译器为实现语言动态特性将自动创建一些数据结构和函数，而这些数据结构就包含类定义和协议类定义中的信息，如类的对象，协议类的对象，方法选标，实例变量模板，以及其他来自于源代码的信息。运行时系统的主要功能就是根据源代码中得表法师发送消息。</li>
<li>通过Foundation框架中NSObject的方法:由于Cocoa框架里面大多数类是集成自NSObject，而NSObject里面有很多方法都是可以在运行时获取动态信息，例如，NSObject的一个description方法，它不知道子类子类的详细信息，所以它直接返回类的名字和对象的地址，子类可以重写该方法来返回更多的信息，例如NSArray，他就把NSArray包含的每个类的内容返回，类似的方法还有isKindOfClass，isMemberOfClass等等一些允许对象在一定程度上自我检查的方法，意思就是说，NSObject提供了很多在运行时获取信息的方法来让我们去调用去拓展。</li>
<li>通过直接调用运行时系统的函数：运行时系统是一个有公开接口的动态库，有一些数据结构和函数的集合组成，使用时要导包#import &lt;objc/runtime.h>，这些函数是的访问运行时系统借口和提供开发工具成为肯呢过，虽然他们对程序不是必须得，但是有时候对于OC程序来说某些函数是非常有用的，例如我们经常用到的，用来获取一个类的私有属性的时候用到的方法</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Ivar</span> <span class="o">*</span> <span class="n">ivars</span> <span class="o">=</span> <span class="n">class_copyIvarList</span><span class="p">([</span><span class="o">&lt;</span><span class="err">#</span><span class="kt">Class</span><span class="err">#</span><span class="o">&gt;</span> <span class="k">class</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">Ivar</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ivars</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">ivars</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Ivar</span> <span class="k">const</span> <span class="n">ivar</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithUTF8String</span><span class="p">:</span><span class="n">ivar_getName</span><span class="p">(</span><span class="n">ivar</span><span class="p">)];</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>消息</h3>

<h4>获取方法地址</h4>

<ul>
<li>避免动态绑定的唯一办法就是去的方法的地址，当一个方法会被连续调用很多次，而且你希望节省每次调用方法都要发送消息的开销时，使用方法地址来调用就显得很有效。</li>
<li>利用NSObject类中得methodForSelector:方法，你可以获得一个指向<code>方法实现</code>的指针，并且可以使用该指针直接调用方法实现。methodForSelector:返回的指针和复制的变量类型必须完全一致，包括方法的参数诶性和返回值类型都在类型识别的考虑范围中。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">setter</span><span class="p">)(</span><span class="kt">id</span> <span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span><span class="kt">BOOL</span><span class="p">);</span><span class="c1">//这里类似于Block Block是指向结构体的指针，这是指向函数的指针</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="k">setter</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">id</span><span class="p">,</span><span class="kt">SEL</span><span class="p">,</span><span class="n">BOOK</span><span class="p">))[</span><span class="n">target</span> <span class="nl">methodForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">setFilled</span><span class="p">)];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'><span class="k">setter</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="k">@selector</span><span class="p">(</span><span class="nl">setFilled</span><span class="p">:)</span> <span class="p">,</span><span class="nb">YES</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法指针的第一个参数是接受消息的对象(self),第二个参数是方法选标(_cmd),这两个参数在方法中是隐藏参数，但使用函数的形式来调用方法是必须显示的给出。</li>
<li>使用methodForSelector:来避免动态绑定讲较少大部分消息的开销，但是这只有在制定的消息被重复发送很多次是才有意义。
<code>注意,methodForSelector:是 Cocoa 运行时系统的提供的功能,而不是 Objective-C 语言本身的功 能。</code></li>
</ul>


<h4>objc_msgSend函数</h4>

<ul>
<li>在Objective-C中，消息是知道运行的事后彩盒方法实现绑定的，编译器会把一个消息表达式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">receiver</span> <span class="n">messgae</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>转换成一个对消息函数objc_msgSend的调用，干函数有两个主要参数，消息接受者和消息对应的名字&mdash;也就是方法的选标，也就是上面所说的指向函数的指针。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>同时接收消息中得任意数目的参数，返回的指针和复制的变量类型必须完全一致，包括方法的参数诶性和返回值类型都在类型识别的考虑范围中。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">￼￼￼￼</span><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>该消息函数做了动态绑定所需要得一切

<ul>
<li>他首先找到选标对应的方法实现。</li>
<li>然后讲消息接受者对象 ，以及方法中制定的参数传给找到的方法实现</li>
<li>最后讲方法实现的返回值作为该函数的返回值返回,<code>注意:编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素:(self和_cmd)</code></li>
<li>指向父类的指针。</li>
<li>类的方法表。方法表讲方法选标和该类的方法实现地址以key-value的方式存起来。</li>
</ul>
</li>
<li>当新的对象被创建是，其内存同时被分配，实例变量也同时被初始化。对象的<code>第一个实例变量</code>是一个指向该对象的类结构的指针，叫做isa，通过该指针对象可以访问他对应类以及相应的父类。
<code>注意：尽管严格来说这并不是Objective-C语言的一部分，但是在Objective-C运行时系统中对象需要有isa指针。对象和结构体struct objc_object(在objc/objc.h中定义)必须一致，燃和你很少需要创建你自己的跟对象，因为从NSObject或者NSProxy继承的对象都自动包括isa变量</code></li>
</ul>


<p><img src="http://etund.github.com/images/blog/Objective-c-Runtime/messaging1.gif" alt="消息框架" /></p>

<ul>
<li>当对象收到消息后，消息函数首先根据对象的isa指针找到该对象所对应累的方法表，并从表中寻找该消息对应的方法选标。如果找不到，objc_msgSend将继续从父类中找，知道NSObject类。一旦找到方法，一旦找到方法选标，objc_msgSend则以消息接收者对象为参数调用，调用该选标对应的方法实现。这就是在运行时系统徐哲方法实现的方式，在面向对象编程中(例如java编程),一般承租方法和消息动态绑定的过程。</li>
<li>为了加快消息的处理过程，运行时系统通常会讲使用过的方法选标和方法实现的地址翻入缓存，如果一个方法被使用过一次，那么它很有可能被再次使用，如果缓存中已经有了需要的方法选标，则消息仅仅比函数调用慢一点点，如果程序运行了足够长的时间，几乎每个消息都能在混村中找到那方法实现。程序运行时，混存也将随着新的消息的增加而增加。</li>
</ul>


<h4>使用隐藏参数</h4>

<ul>
<li>当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数搜传递给方法实现，同时它还将传递两个隐藏的参数：(self和_cmd)，具体怎么调用这两个隐藏参数，请看以下代码。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="nf">strange</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="kt">id</span> <span class="n">target</span> <span class="o">=</span> <span class="n">getTheReceiver</span><span class="p">();</span>
</span><span class='line'><span class="kt">SEL</span> <span class="n">method</span> <span class="o">=</span> <span class="n">getTheMethod</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="n">target</span> <span class="o">==</span> <span class="nb">self</span> <span class="o">||</span> <span class="n">method</span> <span class="o">==</span> <span class="n">_cmd</span> <span class="p">)</span>
</span><span class='line'><span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="p">[</span><span class="n">target</span> <span class="nl">performSelector</span><span class="p">:</span><span class="n">method</span><span class="p">];</span>
</span><span class='line'><span class="err">￼</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考博文</h3>

<p><a href="http://blog.devtang.com/blog/2013/04/29/the-missing-objc-keywords/">那些被遗漏的Objective-C保留字</a></p>

<p><a href="http://onevcat.com/2012/04/objective-c-runtime/">深入Objective-C的动态特性</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDynamic简单使用]]></title>
    <link href="http://etund.github.com/blog/2014/07/02/uidynamicjian-dan-shi-yong/"/>
    <updated>2014-07-02T22:46:29+08:00</updated>
    <id>http://etund.github.com/blog/2014/07/02/uidynamicjian-dan-shi-yong</id>
    <content type="html"><![CDATA[<h2>UIDynamic(一)</h2>

<h4>前言</h4>

<ul>
<li>最近工作之余，看了一下UIDynamic，UIDynamic是13年WWDC出得技术。其实本人一直热衷于比较有趣的动画，特别是带物理力学的动画，感觉物理力学就是动画的灵魂，一直想找几个小伙伴把物理与动画结合起来，做一下类似于物理引擎的迷你版玩玩，但是由于可支配时间不多，以至于这个夙愿未能完成，但发现UIDynamic这套UIKit自带的物理引擎也挺好玩的，所以先玩几天把，好了，废话不多说，直入正题。</li>
</ul>


<h4>基础</h4>

<ul>
<li>概念

<ul>
<li>UIDynamicItem:一个控件想要执行UIDynamicAnimator的动画就必须要继承这个协议。</li>
<li>UIDynamicAnimator:Animator为动态控件提供物理相关的力学和动画，也为这些动画提供了上下文，通过添加Behavier实例来实现想要的动画效果，在以下介绍到的物理力学里面一切动画的源头都是他，也可以说，UIKit的动力学最外层的包装就是它。</li>
<li>ReferenceView:在初始化UIDynamicAnimator的时候有一个叫做referenceView的属性，他是你的参考视图，你的子控件以及子控件的Beahavier就是参考这个视图的坐标的。</li>
<li>UIDynamicBehavior:它可以看做是把一种物理行为封装起来的一个类，一个Behavior实例可以赋予多个动态控件的一个物理行为。</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>扩展</p>

<ul>
<li>一个动态控件可以是任何遵循UIDynamicItem协议的iOS或者自定义对象，UIView和UICollectionViewLayeroutAttributes类都实现了这个协议，你可以自定义遵循这个协议的的控件来使用这个物理动画。</li>
</ul>
</li>
<li><p>层次</p>

<ul>
<li>UIDynamicBehavior苹果官方提供了六种物理行为的封装,换言之，苹果官方对外只提供了六种基本的物理行为，但你可以自定义符合的物理行为，不过你自定义的这个行为必须继承UIDynamicBehavior.其层次如下</li>
</ul>


<p>  <img src="http://etund.github.com/images/blog/UIDynamic/Snip20150720_4.png" alt="" /></p></li>
</ul>


<h4>应用场景</h4>

<ul>
<li>UIGravityBehavior:重力行为，来个自由落体</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="o">=</span> <span class="bp">UIDynamicAnimator</span><span class="p">(</span><span class="nl">referenceView</span><span class="p">:</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">gravity</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="n">gravity</span> <span class="o">=</span> <span class="bp">UIGravityBehavior</span><span class="p">(</span><span class="nl">items</span><span class="p">:</span> <span class="p">[</span><span class="n">littleBall</span><span class="p">])</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">addBehavior</span><span class="p">(</span><span class="n">gravity</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>- 效果图如下
</code></pre>

<p><img src="http://etund.github.com/images/blog/UIDynamic/gavity.gif" alt="" /></p>

<p><code>我们还可以通过magnitude来设置重力加速度，值得一提的是，学过物理的同学应该知道这个吧，不过苹果这里面跟现实还是有些出入的，就像我们现实中g是9.8m/s²,而在UIKit中定义了g是1000 points / second²,换言之,如果一开始我们的速度为0，那么一秒后我们的速度是1000个点/秒</code></p>

<ul>
<li>UICollisionBehavior:碰撞检测行为，是不是觉得感觉自由落体没有真实感，这个可以是我们的屏幕添加地面</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="n">collision</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="n">collision</span> <span class="o">=</span> <span class="bp">UICollisionBehavior</span><span class="p">(</span><span class="nl">items</span><span class="p">:</span> <span class="n">viewArr</span><span class="p">)</span>
</span><span class='line'>    <span class="n">collision</span><span class="p">.</span><span class="n">collisionDelegate</span> <span class="o">=</span> <span class="nb">self</span>
</span><span class='line'>    <span class="n">collision</span><span class="p">.</span><span class="n">addBoundaryWithIdentifier</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">,</span> <span class="nl">fromPoint</span><span class="p">:</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="nl">toPoint</span><span class="p">:</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://etund.github.com/images/blog/UIDynamic/collision.gif" alt="" /></p>

<p><code>注意:我们可以设置UICollisionBehavior的代理，来监听碰撞的行为，我们可以同translatesReferenceBoundsIntoBoundary这个属性来让我们的参考视图边界作为我们的墙壁，也可以通过这个addBoundaryWithIdentifier来设置我们的墙壁</code></p>

<ul>
<li><p>UIDynamicItemBehavior:设置每个动态控件的自身属性，提供一下属性</p>

<ul>
<li>elasticity：弹力</li>
<li>friction：摩擦力</li>
<li>density：密度</li>
<li>resistance：阻力</li>
<li>angularResistance：角阻力</li>
<li>allowsRotation：允许旋转</li>
</ul>
</li>
<li><p>我们暂且用这几个物理行为来做一个比较有趣的动画</p>

<p>  <img src="http://etund.github.com/images/blog/UIDynamic/animator_0.gif" alt="" /></p>

<p>  <img src="http://etund.github.com/images/blog/UIDynamic/animator.gif" alt="" /></p>

<ul>
<li><p>这个的主要思路如下</p>

<ul>
<li><p>重力行为，碰转行为，属性行为</p></li>
<li><p>定时器不断加小球，定时器可以选择NSTimer，CADisplayLink以及GCD，前两个不怎么准确，有时还会跳过任务，所以这里我选择了GCD定时器，NSTimer和CADisplayLink底层也是调用GCD定时器的。</p></li>
<li><p>当小球消失在屏幕中回收内存，这里我是在碰撞代理方法里面回收，也可以用KVO监听来回收内存，但系统自带的KVO好像不好使，可以试一下<code>Observable-Swift</code>这个框架，里面很好的利用了Swift的泛型来实现的。</p></li>
</ul>
</li>
<li><p>核心代码如下</p></li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//        添加GCD定时器，比CADisplayLink和NSTimer更精确，受限制较小</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">queue</span><span class="p">:</span><span class="kt">dispatch_queue_t</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="nl">start</span><span class="p">:</span><span class="kt">dispatch_time_t</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="n">Int64</span><span class="p">((</span><span class="n">UInt64</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="nl">interval</span><span class="p">:</span><span class="n">UInt64</span> <span class="o">=</span> <span class="n">UInt64</span><span class="p">((</span><span class="n">UInt64</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">dispatch_source_set_event_handler</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="p">{</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">addABall</span><span class="p">()</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'>    <span class="n">dispatch_resume</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">timer</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// addBall()方法里面</span>
</span><span class='line'>        <span class="n">let</span> <span class="nl">littleBall</span><span class="p">:</span><span class="n">LittleBall</span> <span class="o">=</span> <span class="n">LittleBall</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">CGFloat</span><span class="p">(</span><span class="n">arc4random_uniform</span><span class="p">(</span><span class="kt">UInt32</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</span><span class='line'>        <span class="n">littleBall</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">randomColor</span><span class="p">();</span>
</span><span class='line'>        <span class="n">littleBall</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">littleBall</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">viewArr</span> <span class="o">+=</span> <span class="p">[</span><span class="n">littleBall</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">gravity</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="n">gravity</span> <span class="o">=</span> <span class="bp">UIGravityBehavior</span><span class="p">(</span><span class="nl">items</span><span class="p">:</span> <span class="n">viewArr</span><span class="p">)</span>
</span><span class='line'>        <span class="n">gravity</span><span class="p">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">collision</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="n">collision</span> <span class="o">=</span> <span class="bp">UICollisionBehavior</span><span class="p">(</span><span class="nl">items</span><span class="p">:</span> <span class="n">viewArr</span><span class="p">)</span>
</span><span class='line'>        <span class="n">collision</span><span class="p">.</span><span class="n">collisionDelegate</span> <span class="o">=</span> <span class="nb">self</span>
</span><span class='line'>        <span class="n">collision</span><span class="p">.</span><span class="n">addBoundaryWithIdentifier</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">,</span> <span class="nl">fromPoint</span><span class="p">:</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="nl">toPoint</span><span class="p">:</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">itemBehavior</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="n">itemBehavior</span> <span class="o">=</span> <span class="bp">UIDynamicItemBehavior</span><span class="p">(</span><span class="nl">items</span><span class="p">:</span> <span class="n">viewArr</span><span class="p">)</span>
</span><span class='line'>        <span class="n">itemBehavior</span><span class="p">.</span><span class="n">elasticity</span> <span class="o">=</span> <span class="mf">0.5</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">removeAllBehaviors</span><span class="p">()</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">addBehavior</span><span class="p">(</span><span class="n">gravity</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">addBehavior</span><span class="p">(</span><span class="n">itemBehavior</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">addBehavior</span><span class="p">(</span><span class="n">collision</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//在代理方法里面</span>
</span><span class='line'>        <span class="n">let</span> <span class="nl">view</span><span class="p">:</span><span class="bp">UIView</span> <span class="o">=</span> <span class="n">item</span> <span class="n">as</span><span class="o">!</span> <span class="bp">UIView</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">width</span><span class="p">{</span>
</span><span class='line'>                <span class="n">let</span> <span class="nl">arr</span><span class="p">:</span><span class="bp">NSMutableArray</span> <span class="o">=</span> <span class="bp">NSMutableArray</span><span class="p">(</span><span class="nl">array</span><span class="p">:</span> <span class="nb">self</span><span class="p">.</span><span class="n">viewArr</span><span class="p">)</span>
</span><span class='line'>                <span class="n">view</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
</span><span class='line'>                <span class="n">arr</span><span class="p">.</span><span class="n">removeObject</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">viewArr</span> <span class="o">=</span> <span class="n">arr</span> <span class="n">as</span> <span class="p">[</span><span class="n">AnyObject</span><span class="p">]</span>
</span><span class='line'>            <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多对象内存管理]]></title>
    <link href="http://etund.github.com/blog/2014/06/01/duo-dui-xiang-nei-cun-guan-li/"/>
    <updated>2014-06-01T22:39:03+08:00</updated>
    <id>http://etund.github.com/blog/2014/06/01/duo-dui-xiang-nei-cun-guan-li</id>
    <content type="html"><![CDATA[<h3>多对象内存管理(非ARC)</h3>

<ul>
<li>在非ARC中，多个对象内存管理要注意一些问题，例如循环利用，还有就是自己手写Set方法的时候要注意一些问题</li>
<li>指针释放 (set方法)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">Person</span> <span class="o">*</span><span class="n">per</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Room</span> <span class="o">*</span><span class="n">r1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Room</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">per</span><span class="p">.</span><span class="n">room</span> <span class="o">=</span> <span class="n">r1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">r1</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">per</span> <span class="k">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>由于执行完per.room = r1之后有两个指针指向同一份内存，[r1 release]后,r1所指向的内存空间被回收掉了，我们如果再像调用per.room就会报<code>message sent to deallocated instance</code>错误，所以我们要在Person里面做一些操作</li>
</ul>


<!-- more -->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setRoom:</span><span class="p">(</span><span class="n">Room</span> <span class="o">*</span><span class="p">)</span><span class="nv">room</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">room</span> <span class="k">retain</span><span class="p">];</span>
</span><span class='line'>    <span class="n">_room</span> <span class="o">=</span> <span class="n">room</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_room</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果当我们要把per.room 的指针指向其他Room对象的时候，例如</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">Person</span> <span class="o">*</span><span class="n">per</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Room</span> <span class="o">*</span><span class="n">r1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Room</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">Room</span> <span class="o">*</span><span class="n">r2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Room</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%zd&quot;</span><span class="p">,[</span><span class="n">r1</span> <span class="n">retainCount</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">per</span><span class="p">.</span><span class="n">room</span> <span class="o">=</span> <span class="n">r1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">per</span><span class="p">.</span><span class="n">room</span> <span class="o">=</span> <span class="n">r2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%zd&quot;</span><span class="p">,[</span><span class="n">r1</span> <span class="n">retainCount</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">r1</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">per</span><span class="p">.</span><span class="n">room</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">per</span> <span class="k">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这是Room不会调用r1的dealloc方法，因为之前在set方法里面执行了一次retain操作，后面没有release操作，所以在set方法里面要先对前面的对象做一次release操作</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setRoom:</span><span class="p">(</span><span class="n">Room</span> <span class="o">*</span><span class="p">)</span><span class="nv">room</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_room</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">room</span> <span class="k">retain</span><span class="p">];</span>
</span><span class='line'>    <span class="n">_room</span> <span class="o">=</span> <span class="n">room</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>但是，如果我们继续不断调用set方法，例如</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">r1</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">r2</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="n">per</span><span class="p">.</span><span class="n">room</span> <span class="o">=</span> <span class="n">r2</span><span class="p">;</span>
</span><span class='line'><span class="n">per</span><span class="p">.</span><span class="n">room</span> <span class="o">=</span> <span class="n">r2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>系统就汇报野指针错误<code>message sent to deallocated instance 0x10020a4f0</code>,这是，因为当我们执行set方法的时候，room指向的内存的计数器为1 ,我们上面做的操作是在set方法里面先做release,当person的<em>room属性跟传进来的room属性一样的时候，那么在[</em>room release]后面room指向的就成了僵尸对象，那么room就成了野指针，所以会报坏内存访问，这时要做如下操作</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setRoom:</span><span class="p">(</span><span class="n">Room</span> <span class="o">*</span><span class="p">)</span><span class="nv">room</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">_room</span> <span class="o">!=</span> <span class="n">room</span><span class="p">){</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_room</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_room</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span> <span class="k">retain</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>总结：谁retain谁release</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理简单回顾]]></title>
    <link href="http://etund.github.com/blog/2014/05/31/nei-cun-guan-li-she-xi/"/>
    <updated>2014-05-31T22:34:18+08:00</updated>
    <id>http://etund.github.com/blog/2014/05/31/nei-cun-guan-li-she-xi</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<ul>
<li>程序员也要有自己的成长方式，每行都要有历练，程序员也不例外，时刻保持着接受历练的准备</li>
</ul>


<h3>内存管理简单回顾</h3>

<ul>
<li>增加一个app的内存占用

<ul>
<li>创建一个OC对象</li>
<li>定义一个变量</li>
<li>调用一个函数或者方法</li>
</ul>
</li>
<li>当app所占用的内存较多时，系统发出内存警告，这时回收一些不需要再使用的内存空间</li>
<li>所谓内存管理，就是对内存进行管理，涉及的操作有

<ul>
<li>分配内存：比如创建一个对象，会增加内存占用</li>
<li>清除内存：比如销毁一个对象，能减少内存占用</li>
</ul>
</li>
<li>内存管理的管理范围

<ul>
<li>任何继承NSObject的对象</li>
<li>对其他非对象类型无效(int char float double struct enum)</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>只有OC对象才需要进行内存管理的本质原因</p>

<ul>
<li>OC对象存放于堆里面</li>
<li>非OC对象一般放在栈里面(栈内存会被系统自动回收)</li>
</ul>
</li>
<li><p>什么是引用计数器</p>

<ul>
<li>每个OC对象都有自己的引用计数器</li>
<li>他是一个整数</li>
<li>从字面上，可以理解为"对象被引用的次数"</li>
<li>也可以理解为：他表示有多少人正在使用这个对象
<code>每个OC对象内部都有4个字节的存储空间来存放引用计数器</code></li>
</ul>
</li>
<li>医用计数器的常见操作

<ul>
<li>给对象发送一条retain消息，可以是引用计数器值+1(retain方法返回对象本身)</li>
<li>给对象发送一条release消息，可以使引用计数器-1</li>
<li>给对象发送retainCount消息，可以获得当前引用计数器值
<code>需要注意的是：release并不代表销毁\回收对象，仅仅是计数器-1</code></li>
</ul>
</li>
<li>dealloc： 当一个对象的引用计数器为0时

<ul>
<li>这个对象即将被销毁，其占用的的内存被系统回收</li>
<li>系统会自动给对象发送一条dealloc消息</li>
<li>一般重写dealloc方法，就必须调用[super dealloc]，并且放在最后面调用</li>
<li>使用注意

<ul>
<li>不能直接调用dealloc方法</li>
<li>一旦对象被回收了，它占的内存就不再可用，坚持使用会导致程序崩溃(野指针错误)</li>
</ul>
</li>
</ul>
</li>
<li>僵尸对象

<ul>
<li>已经被销毁的对象(不能在使用的对象)</li>
</ul>
</li>
<li>野指针

<ul>
<li>指向僵尸对象(不可用内存的指针)</li>
<li>给野指针发消息会报EXC_BAD_ACCESS错误</li>
<li>解决方法

<ul>
<li>在对象销毁之后，将指向对象的指针变为空指针
-空指针</li>
</ul>
</li>
<li>没有指向内存空间的指针</li>
</ul>
</li>
<li>@property参数

<ul>
<li>retain:release旧值，retain新值(用于OC对象)</li>
<li>assign: 直接赋值，不做任何内存管理(默认，用户非OC对象类型)</li>
<li><p>copy: release旧值，copy新值</p></li>
<li><p>控制需不需要生成set，get方法</p>

<ul>
<li>readwrite : 同时生成set方法和get方法(默认)</li>
<li>readonly : 只会生成get方法</li>
</ul>
</li>
<li>多线程管理

<ul>
<li>atomic ： 性能低(默认),线程安全</li>
<li>nonatomic : 性能高，线程不安全</li>
</ul>
</li>
</ul>
</li>
<li>可能跟随机的区别

<ul>
<li>今天可能下雨，因为下雨跟很多因数有关，那么好像也可以说，今天下不下雨是随机的，貌似可能跟随机是一样的额，但是如果我没见过一个人，Ta的性别无非就是男跟女，那么他的性别是随机的吗，貌似不行，因为每个人得性别是确定的。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UINavigation日常Bug]]></title>
    <link href="http://etund.github.com/blog/2014/02/26/uinavigationri-chang-bug/"/>
    <updated>2014-02-26T19:59:31+08:00</updated>
    <id>http://etund.github.com/blog/2014/02/26/uinavigationri-chang-bug</id>
    <content type="html"><![CDATA[<h3>UINavigation日常Bug</h3>

<ul>
<li>今天整理公司项目的时候,发现一个Bug，挺有意思的，就是在你不断调用Navigation<code>- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;</code>方法的时候，发现在不断点击一个按钮来调用这个方法，在点击返回调用<code>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;</code>这个方法，这是在多次点击返回不但没有返回，还多次向Navigition里面添加控制器。</li>
</ul>


<p><img src="http://etund.github.com/images/blog/UINavigationBug/bug_0.gif" alt="" /></p>

<!-- more -->


<ul>
<li>额，黑苹果录制有点缺陷，自行脑补画面哈。</li>
<li>这是什么问题呢，代码不多，可以看看，那么问题究竟出在哪里呢？</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//push</span>
</span><span class='line'><span class="c1">//触发点击事件</span>
</span><span class='line'><span class="p">[</span><span class="n">btn</span> <span class="nl">addTarget</span><span class="p">:</span><span class="n">target</span> <span class="nl">action</span><span class="p">:</span><span class="n">action</span> <span class="nl">forControlEvents</span><span class="p">:</span><span class="n">UIControlEventTouchUpInside</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//接收按钮点击处理</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">btnClick:</span><span class="p">(</span><span class="bp">UIButton</span> <span class="o">*</span><span class="p">)</span><span class="nv">btn</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationController</span> <span class="nl">pushViewController</span><span class="p">:[[</span><span class="n">ETRecommendController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//pop</span>
</span><span class='line'><span class="c1">//触发点击时间</span>
</span><span class='line'><span class="p">[</span><span class="n">backBtn</span> <span class="nl">addTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
</span><span class='line'><span class="c1">//接受点击事件</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">pop</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">popViewControllerAnimated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>看看现在的分析</li>
<li>我想点击push就调用push方法，返回就调用pop，并且只调用一次。</li>
<li>现在点击push的确是显示一次，点击pop的时候，明显的看到添加了好多子控制器进去,而实际上也的确添加了好多自控器（实际的确如此）</li>
<li>这里我是自定义Navigation的，那么可能是我自定义里面的代码里面写逻辑不对，与系统的冲突，于是换了系统的Navigation，然而结果一样。</li>
<li><p>不得不说一个细节是在按钮的两端点才回出现这个bug,在中间点则一切正常。</p></li>
<li><p>于是乎我发现在接受按钮push点击事件的方法调用多次，但是明明看到我还没返回根控制器啊，同时也看到我点击的返回按钮啊，突然间我发现我是这样调用push方法的<code>[self.navigationController pushViewController:[[ETRecommendController alloc] init] animated:YES];</code>注意后面的<code>animated:YES</code>Navigation的跳转带动画效果，而这个动画效果是通过CoreAnimation的专场动画来实现的，而动画的需要时间，而在RunLoop里面的NSDispalyLink与NStimer那么如果在一定时间内没有执行完任务会自动跳过，而现在会不会类似这样呢，毕竟是都是基于线程运行的，而线程的架构模式又是RunLoop,亦即是说<code>执行动画需要时间，在这个时间里面没有执行完动画，那么RunLoop直接处理下一个Source</code>。</p></li>
<li><p>额&hellip;，如果是这样的话，那么直接把动画设为NO就行了吧，于是把YES换成NO，的确，一点问题也没有，问题这样似乎是解决了，请留意我上面说的一个细节。</p></li>
<li><p><code>在按钮的两端点才回出现这个bug,在中间点则一切正常</code>
<img src="http://etund.github.com/images/blog/UINavigationBug/bug_1.gif" alt="" /></p></li>
<li><p>如果说在两端和中间点击的效果一样的话，这样动画的YES和NO就很有说服力了，但是现在明显不是。</p></li>
<li><p>于是乎现在又是这样一个状况</p>

<ul>
<li><p>在我们点击过去的时候，push键(非返回键)动画效果的时候，变成了这样一个局势：中间的一个模块不能接收相应，而周围可以，也就是说，中间和周围不是同一块控件，毕竟根据响应者链条，寻找最合适的View，所以，如果能接收事件那他一定是同一块View，除非他不遵循响应者链条，而现在就是这个局势，一个控件居然不遵循响应者链条，好吧，这个猜想有点大胆，理由也比较勉强。</p></li>
<li><p>这里需要普及一下苹果的一些细节的知识，在我们点击iPhone键盘的时候，例如我点击了g，那么苹果会从他系统自带的猜词字典里面猜想我们下一个会按什么，这是可能是good，也可能是god，但是可以肯定的是o的触控范围一定比某一些字母的触控范围大，也就是说虽然我们看起来键盘一直没有变化，他的每个字母能接受事件的范围永远都在动态变化的，这也是苹果用户体验比较好的一个细节。</p></li>
<li><p>行了，有了上面的小提示，你应该想到我接下来要讲什么了吧，就是我们的返回按钮的接收事件的范围会被放大，当然这只是我的一个猜想，那么如果我的猜想成功的话，现在就是这个局势，中间一个push键的确push后不能点击，但是他的响应范围被放大了，所以就形成了中间点击正常，边框点击会调用push方法，这样猜想貌似合理，这种猜想与上面的那种猜想结合起来应该会比较合理，但是毕竟是猜想。</p></li>
</ul>
</li>
<li><p>至于解决方案，很简单，我猜你也想到了，不过为什么会出现这个bug，这才是最重要的，至少求学态度没有错，解决方案：大体是：</p>

<ul>
<li>如果是自定义Navigation的话，可以在重写的push方法里面检查navigation里面是否已经存在了这个控制器。</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">checkIsExit:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">VC</span><span class="p">{</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">classObj</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">childViewControllers</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="k">class</span> <span class="o">=</span> <span class="p">[</span><span class="n">classObj</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">VC</span> <span class="nl">isKindOfClass</span><span class="p">:</span><span class="k">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果是系统的话，可以在navigation的childrenControllers的count的变化的时候判断是否取出最后一个，这里可能会用到KVC，需要提醒的是，系统的KVO并不是对一切属性都可用的，如果是使用Swift的话推荐一个第三方框架<code>Observable-Swift</code>，这个框架很好的利用了Swift的泛型，如果的OC，自行到github上寻找框架。</li>
</ul>

]]></content>
  </entry>
  
</feed>
